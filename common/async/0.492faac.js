webpackJsonp([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],{290:function(s,e){s.exports='<h1 id="-">赣江边上</h1>\n<p>date:   2015-06-05 22:13:35 +0800</p>\n<h3 id="-think-">分类: [Think]</h3>\n<hr>\n<p>南昌连续几天阴雨绵绵，终于在6日的早晨迎来了只持续了2分钟的日出，之后的太阳又隐在了层层的云中。</p>\n<p>江面有层薄雾，远处含羞的是八一大桥，其实在雾中隐去的，还有千古奇人——王勃——的滕王阁。</p>\n<p>他是我第三个偶像，我第一个偶像是毛泽东，第二个是李白。</p>\n<p>我终是和我的偶像有些相同的地方的。</p>\n<p>面对着东方，我不禁小声的背出声来：“阁中帝子今何在？槛外长江空自流”</p>\n<p>还有人看到这张图想起这个诗句：“日暮乡关何处是，明朝散发弄扁舟”</p>\n<p>可惜这扁舟是电动的————纯属娱乐，哈哈 ^_^</p>\n<p><img src="http://img.xheldon.com/img/ganjiang.png" alt="赣江" title="赣江边上"></p>\n'},291:function(s,e){s.exports='<h1 id="mac-os-x-sz-rz-">Mac OS X 使用 sz/rz 命令下载/上传文件配置</h1>\n<p>date:   2015-07-20 22:13:35 +0800</p>\n<h3 id="-others-">分类: [Others]</h3>\n<hr>\n<p><code>OS X</code> 自带的终端可以直接连接 <code>Linux</code> （相比之下, <code>Win</code> 的 <code>cmd</code> 就比较渣了）, 但是有个问题就是, 终端无法直接通过 <code>Zmodem</code> 来上传和下载文件, 这里就需要一款更强大的远程服务器连接工具: <code>iTerm</code> 的帮助了. </p>\n<p>网上很多的教程, 但是有的是为了提高访问量随便粘贴的, 完全不负责任, 讲的也不仔细, 我也是连蒙带猜费了半天的劲儿才搞好的, 坑爹. 下面我尽量使用比较浅显的话来给大家讲解. </p>\n<p>好了废话不多说, 咱们进入正题: 如何在 <code>Mac OS X</code> 下使用 <code>Zmodem</code> 中的 <code>rz/sz</code> 来上传和下载文件. </p>\n<h2 id="-iterm2">第一步: 下载 <code>iTerm2</code></h2>\n<p>首先明确, 使用自带的终端是不行的, 我们需要下载一款比终端更强大的 <code>shell</code> 工具: <a href="http://www.iterm2.cn/download" target="_blank"><code>iTerm2</code> </a></p>\n<p>下载下来是个 <code>zip</code> 的压缩包, 直接解压就得到了以 <code>.app</code> 为后缀名的可执行文件, 双击打开就是 <code>iTerm2</code> 的窗口了, 过程中有警告窗口的话同意即可（就相当于是 <code>Win</code> 下的绿色软件一样无需安装）</p>\n<h2 id="-iterm2-brew">第二步: 使用 <code>iTerm2</code> 安装 <code>brew</code></h2>\n<p><code>brew</code> 是一个包管理程序, 使用它可以方便的安装各种软件, 而无需输入地址, 作用相当于 <code>AppStore</code> 一样, 具体介绍请参看官网. 安装 <code>brew</code> 很简单, 使用刚刚下载后解压打开的 <code>iTerm2</code>, 输入</p>\n<pre><code class="hljs bash">ruby -e "$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/<span class="hljs-keyword">install</span>/<span class="hljs-keyword">master</span>/<span class="hljs-keyword">install</span>)<span class="hljs-string">"</span>\n</code></pre>\n<p>即可. 如图:</p>\n<p><img src="http://img.xheldon.com/img/brew_install.png" alt="brew install" title="brew install"></p>\n<p>回车: </p>\n<p><img src="http://img.xheldon.com/img/brew_install2.png" alt="brew install" title="brew install"></p>\n<p>注意看安装过程中的提示, 我在文字停止显示时就以为是安装好了, 于是开心的 <code>ls</code> 起来, 结果发现停止时是需要按下 <code>return</code> 来确认的, 按其他键就会退出安装, 过程需要按下两次 <code>return</code>, 最后显示:</p>\n<pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">Downloading</span></span> <span class="hljs-keyword">and</span> installing Homebrew...\n</code></pre>\n<p>才开始下载和安装 <code>brew</code> 这点要记住. </p>\n<p>再来一次: </p>\n<p><img src="http://img.xheldon.com/img/brew_install3.png" alt="brew install" title="brew install"></p>\n<p>成功会提示这个: </p>\n<p><img src="http://img.xheldon.com/img/brew_install4.png" alt="brew install" title="brew install"></p>\n<p>注意, 如果通过 <code>iTerm2</code> 的 <code>brew</code> 安装不上 <code>lrzsz</code>（包括各种情况的报错 ）, 请<a href="https://ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz" target="_blank">手动下载 <code>lrzsz</code> </a>, 这里是<a href="https://ohse.de/uwe/software/lrzsz.html" target="_blank"> <code>lrzsz</code> 的官网</a></p>\n<p>需要将下载的 <code>zip</code> 压缩之后放到 <code>brew</code> 的缓存目录下: <code>/Library/Caches/Homebrew/</code></p>\n<h2 id="-brew-lrzsz">第三步: 使用 <code>brew</code> 安装 <code>lrzsz</code></h2>\n<p>在 <code>iTerm2</code> 中输入: </p>\n<pre><code class="hljs bash"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>lrzsz\n</code></pre>\n<p>无需操作, 看到成功提示即可, 如图: </p>\n<p><img src="http://img.xheldon.com/img/rzsz.png" alt="rz sz" title="rz sz"></p>\n<h2 id="-iterm2">第四步: 配置 <code>iTerm2</code></h2>\n<p>首先需要下载两个脚本文件, 放到 <code>/usr/local/bin</code> 目录下, 这里是<a href="https://github.com/mmastrac/iterm2-zmodem" target="_blank">下载地址</a>, 点击 <code>Github</code> 页面的右下角的 <code>Download ZIP</code> 即可. \n如图: </p>\n<p><img src="http://img.xheldon.com/img/githubdownload.png" alt="githubdownload" title="githubdownload"></p>\n<p>下载之后解压文件, <code>cd</code> 到这个解压的文件夹（名字是 <code>iterm2-zmodem-master</code>,要用 <code>root</code> 权限: <code>sudo -i</code> ）, 通过终端或者 <code>iTerm2</code> <code>copy</code> 文件到 <code>/usr/local/bin</code> 目录即可\n命令为（假设当前已经 <code>cd</code> 到 <code>iterm2-zmodem-master</code> 文件夹）: </p>\n<pre><code class="hljs bash">cp iterm2-<span class="hljs-keyword">recv</span>-zmodem.sh /usr/<span class="hljs-keyword">local</span>/bin/iterm2-<span class="hljs-keyword">send</span>-zmodem.sh（回车） \ncp iterm2-<span class="hljs-keyword">send</span>-zmodem.sh /usr/<span class="hljs-keyword">local</span>/bin/iterm2-<span class="hljs-keyword">send</span>-zmodem.sh（回车）\n</code></pre>\n<p>之后在 <code>iTerm2</code> 的设置界面 <code>iTerm</code> <code>偏好设置-&gt; Profiles -&gt; Default -&gt; Advanced -&gt; Triggers</code> 的 <code>Edit</code>按钮\n点击 <code>+</code> 号, 加上以下 <code>trigger</code> 信息: </p>\n<pre><code class="hljs bash">Regular <span class="hljs-string">expression:</span> \\*\\*B0100\n<span class="hljs-string">Action:</span> Run Silent Coprocess\n<span class="hljs-string">Parameters:</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>iterm2-send-zmodem.sh \nRegular <span class="hljs-string">expression:</span> \\*\\*B00000000000000\n<span class="hljs-string">Action:</span> Run Silent Coprocess\n<span class="hljs-string">Parameters:</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>iterm2-recv-zmodem.sh\n</code></pre>\n<p>如图: </p>\n<p><img src="http://img.xheldon.com/img/triger.png" alt="trigger" title="trigger"></p>\n<h2 id="-rz-sz-">第五步: 尽情 <code>rz/sz</code> 吧！</h2>\n<p>之后连接服务器</p>\n<p><img src="http://img.xheldon.com/img/connect.png" alt="connect" title="connect"></p>\n<p>连接之后试试输入 rz 就会弹出一个对话框让选择需要上传的文件, 大功告成！</p>\n<p><img src="http://img.xheldon.com/img/success.png" alt="success" title="success"></p>\n'},292:function(s,e){s.exports='<h1 id="-">关于收集用户隐私的看法</h1>\n<p>date:   2015-10-01 19:55:23 +0800</p>\n<h3 id="-think-">分类: [Think]</h3>\n<hr>\n<p>今天看新闻，听到主播说著名游戏《愤怒的小鸟》制造商有收集用户隐私，这些隐私包括姓名、性别、邮箱、地理位置、婚姻状况、性取向等，并将信息提供给国外情报机构的行为。 </p>\n<p>老爸于是趁机教育我——他总是抓住任何一个可以教育我的机会教育我，不过最后总是被我教育，这次也不例外——“你看现在坏人这么多，可别上网写自己的真名字，要写网名”。于是下面是我跟某人说过一遍的话再拿过来给老爸说一遍：</p>\n<p>首先需要明确的是，个人信息泄露绝对是不可避免的，但区别是你的个人信息是否被一些别有用心的人收集用作一些不为人知的，不利于社会的用途。</p>\n<p>政府的监控室无处不在的这点你不想被监控也没用，不说美国的什么“棱镜门”。就说中国政府监控的力度绝对不比其他各国差（看看独一无二的身份证和户口制度就知道了）。</p>\n<p>隐私的范畴我不说了，某些人收集用户行为用于商业目的我也不说了，这个在每一个软件的《用户须知》或者必须同意的《用户条款》里面都会有说明。你是自愿那个人信息换取软件的使用权的。\n以下是我的猜测：</p>\n<ol>\n<li><p>我们看到的CCTV12的警察怎么侦查破案，都是可以给公众看的。而技术层面的千里追踪，茫茫人海定位一个特定的人，这在信息社会这是再简单不过而且不能让大多数人知道的事情了。</p>\n</li>\n<li><p>现在已经知道，政府为每一个有身份证信息的公民建立了一个 “档案”，个人公民的所有信息，从出生到死亡，出生地址、小时候生活的地方、小学、中学、高中、大学获奖情况、在校表现、工作地点、婚姻状况、个人财产状况，均一一记录，每个阶段都有人负责，过了之后交给下一个阶段的人继续记录。实际上，实体档案存在，信息时代的电子档案也存在。</p>\n</li>\n<li><p>政府为每一个有身份证信息的公民建立了一个“电子档案”，你用身份信息注册的QQ账号、微博账号、人人账号、游戏账号。其中，只需要有一个是实名注册，绑定身份证信息，那这个账号记录在你的个人电子信息里面了，其他的只要同时登陆超过一个阈值，也会被认为是这个公民的账号计入记录里。比如，你用身份证注册实名认证了微博，而你刷微博的时候一定有上QQ的时候，那这种情况只要超过几次，同一IP地址就算在你的身份信息里面。有人说，我挂VPN翻墙，挂代理，政府肯定不知道吧？呵呵，办法同上。总能通过各个账号定位你的上网行为，从而监控你。我们强大的政府以社会安全的名义征用这些信息，你还敢拒绝？</p>\n</li>\n<li><p>信息时代没有隐私可言，就像你用你的电脑，以为自己创建的Administor管理员账户是最高权限，想删什么就删什么，想装什么就装什么，可实际是，总有个别的东西你是没有权限访问的，这个时候你才发现，原来还存在一个比自己更高权限的“system”用户。你也不知道你账户使用的密码是否真的保密而不会被某个拥有超级权限的用户读取，分析。真正安全的秘密只能在你的心里面藏着，或者写下来自己藏起来。因为只要交给别人，总会有一些你不知道的事情发生。</p>\n</li>\n<li><p>管理十几亿人口的国家领导人维持社会不至于失控不容易，实行某些强有力手段是必须的。</p>\n</li>\n<li><p>社会主义才适合中国国情，要是实行资本主义，没有一个强力的中央政府，中国应该现在还在内斗。</p>\n</li>\n<li><p>以上属于阴谋论！\nPS：以上若有**字样，均为ZF二字。</p>\n</li>\n</ol>\n'},293:function(s,e){s.exports='<h1 id="-">代码优化/工作经验重要性的一次切身体会</h1>\n<p>date:   2015-10-30 23:04:22 +0800</p>\n<h3 id="-think-">分类: [Think]</h3>\n<hr>\n<p>因为没有项目经验，经常在前端和后端之间的职能上面出错。</p>\n<p>比如我需要实现一个点击按钮用后台给的接口查询数据再用handlebar显示到前端的功能，但是每次查询的数据（返回数组，每项为map类型）都是比较长的，全部一次性加载显示在页面不合适，于是我就排序设计为「每次点击按钮都从后台查询数据」，然后对每次获得的数据做slice处理，每次都截取相同的长度，即第一次截取0到x，第二次截取x到2x，以此类推。</p>\n<p>但是这里有个问题，即我不确定后台SQL查询出来的数据是否order by过，如果没有的话，那我每次点击按钮查询的数据都是无序的，如果不能保证数组的顺序，那就不能保证每次按照顺序截取的数据是自己想要的，因为有可能这次截取的0到x个数组项中包含h项，下一次查询这个h项跑到了x+h项里，再次被查询出来丢到handlebar里面了，这是不对的。</p>\n<p>我当然要再自己力所能及的范围内解决这个问题，于是我打算在前端按照数组中的项中的某个属性如uid来sort一下，这时前端的leader问我在做什么，我说我要sort一下后台查出来的这个无序数组，他就跟我说：</p>\n<p>『这个是后台做的，你前端去做的话会影响性能』</p>\n<p>于是开始跟我解释起来：</p>\n<p>『一般情况下，前端是拿后台给的接口用的，而无需再次对接口查询到的数据做二次处理，不过如果在类似handlebar这种的模板里面，有时候还是需要对查出来的数据中的属性进行拼装处理，再输出到页面，不过你这个情况我可以明确告诉你这个是后台干的事情，他们在给你接口的时候就要保证满足需求』</p>\n<p>『你现在的情况是，你是需要实现翻页功能，但是后端的接口只能每次将所有内容全部查询出来，无法做到需要多少就差多少，也就是说，现有接口无法满足需求，怎么办？两个方案：时间紧的话前端牺牲下性能，直接处理了，时间不紧的话，找后台要接口去，也就是增加一个start，offset的事情，这个接口并不难写。』</p>\n<p>另外还有一个最佳实践：<strong>查询操作越少越好，能从页面获取信息就不要从数据库获取信息</strong>。\n比如后台增加接口之后我仍然需要进行四次查询操作，分别为：初始化、点击加载更多、选项卡切换。每次都有性能损耗，为什么呢？我的逻辑是这样的：</p>\n<p>第一次：页面初始化时候，查询数据并截取固定长度的数组）并将数据放到页面（查询一次），我需要获取每次点击「更多」按钮多少次，由此来判断最大点击次数，而查询到的总数据长度除以每次需要的数据长度，取整+1就得到需要点击的次数，点击这么多次才能把数据都加载出来，然后显示『没有更多啦』按钮（查询一次）这个毫无疑问吧？</p>\n<p>第二次：点击「加载更多」需要查询数据，将需要的长度放到页面上，然后点击次数count+1（查询一次）</p>\n<p>第三次：因为有个我的社区、和我的动态两个选项卡，所以点击这两个按钮的时候都需要查询（查询一次）</p>\n<p>最让人崩溃的是，我居然把我的社区和我的动态这两个选项卡的内容重叠！也即每次点击按钮之后原来的内容是被强行用jQuery的$(container).html()方法替换掉，因为中只有一个容器的缘故（我的设计），所以切换之间只能用html，点击『加载更多』才能用append！\n真是令人羞耻。</p>\n<p>后来我遵循了最佳实践（前面有说过），此外，尽可能的将功能分开和集中来，怎么理解这句话呢？意思就是说，选项卡切换的话，那这个选项卡就负责切换，不管数据查询的事情（功能分开），而『加载更多』按钮就负责查询数据，不干其他的事情，甚至页面初始化的时候也用trigger来触发这个按钮查询数据，而不是在页面加载之初先查询，点击按钮之后再次查询（功能集中）。</p>\n'},294:function(s,e){s.exports='<h1 id="-js-sdk-api-">新浪微博JS SDK API的使用</h1>\n<p>date:   2015-12-21 21:23:45 +0800</p>\n<h3 id="-javascript-">分类: [Javascript]</h3>\n<hr>\n<p>以前整个网站都是老大一个人怼起来的,各种bug和各种细节不完善.所以打算重构一下,侯哥搭好了<code>seajs</code>的开发框架,因此我只需要写前端逻辑即可.</p>\n<p>注册和登陆部分是我写的,因此我打算增加个新浪微博和QQ登陆的功能,用户点击之后存储其id到数据库,当然这个需要修改数据库表字段,单独增加一个类似于<code>wb_id</code>的字段名来标示.</p>\n<p>现在流行的做法有两种,一个是用新浪微博(或其他登录方式,下同)登陆之后,后台自动创建一个id作为本站唯一的标示,同一行的wb_id存储此用户的微博id,以后用任意账号登陆即可,第一次微博登陆之后用户只需要设置一下昵称(非必须,可直接使用微博昵称)和密码(必须,因为万一以后新浪微博倒闭了,用户没法儿登陆可不行);另一种方式是新浪微博登陆之后需要引导用户手动创建一个账号和密码,或者引导用户绑定到已经注册过的用户账号上去.</p>\n<p>好了以上是业务逻辑,我会使用第一种方式实现,下面是具体的实现方法:如何使用新浪微博的JSSDK的API.\n首先和网上大多数教程里面说的那样,需要了解OAuth2.0协议的原理,其实不了解也没关系,知道流程就行,OAuth2.0验证流程网上说的很多了,百度一大把,这里就不再赘述了.</p>\n<p>注意:所有步骤的前提是,你已经取得了新浪微博开放平台的开发者权限,如果没有的话是无权调用API的,关于新浪微博开发者申请,请自行百度.申请完新浪微博开发者之后会到一个appid,这个是新浪识别谁调用了它的API的关键id,之后的步骤也会用到.</p>\n<p>第一步:增加命名空间,引用jssdk文件.</p>\n<p>增加命名空间:</p>\n<pre><code>&lt;html <span class="hljs-string">xmlns:</span>wb=”<span class="hljs-string">http:</span><span class="hljs-comment">//open.weibo.com/wb”&gt;</span>\n</code></pre><p>引用jssdk文件:</p>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">”http://tjs.sjs.sinajs.cn/open/api/js/wb.js?appkey</span>=<span class="hljs-string">YOUR</span> <span class="hljs-attr">APPKEYdebug</span>=<span class="hljs-string">true”</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”text/javascript”</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">”utf-8″</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>其中的<code>YOUR APPKEY</code>替换为你申请新浪微博开发者时它给你的<code>appid</code>, <code>debug=true</code>方便你调试,正式上线时可以把<code>&amp;debug=true</code>这个给删掉.</p>\n<p>第二步:使用API授权登录</p>\n<p>这里有两种方式,一种是点击按钮之后直接在脚本里调用API的<code>WB2.login()</code>方法具体请看新浪API,</p>\n<p>还一种是将用户引导到包含你appid和回调地址的地址中去(姑且叫它授权页),格式为:</p>\n<pre><code>http<span class="hljs-variable">s:</span>//api.weibo.<span class="hljs-keyword">com</span>/<span class="hljs-number">2</span>/oauth2/authorize?client_id=YOUR APPKEY&amp;response_type=token&amp;<span class="hljs-keyword">display</span>=js&amp;transport=html5&amp;referer=Your_CallBack_Address\n</code></pre><p>其中的<code>YOUR APPKEY</code>和<code>Your_CallBack_Address</code>替换为你自己的,注意<code>Your_CallBack_Address</code>记得加上<code>http://</code>\n比如我的测试引导地址就是:</p>\n<pre><code>https:<span class="hljs-regexp">//</span>api.weibo.com<span class="hljs-regexp">/2/</span>oauth2<span class="hljs-regexp">/authorize?client_id=2177891434&amp;response_type=token&amp;display=js&amp;transport=html5&amp;referer=http:/</span><span class="hljs-regexp">/www.xheldon.com/g</span>btagsLogin.html\n</code></pre><p>注意:貌似这个回调地址必须是以php/html/jsp等动态/非动态的带后缀名的格式,如果是首页的话比如<code>http://xheldon.com</code>是不行的,需要加上<code>http://xheldon.com/index.html</code>(因为我的后台是Node的)才行,这个我没有试过,有需要的同学请自行尝试.</p>\n<p>第一种方法的表现形式是点击引导入口之后会直接弹出微博登陆授权页面的对话框,这个时候如果你用过的是<code>chrome</code>的话会发现在这个小窗口的地址栏左侧的地址有个小锁icon,代表这个地址是锁定的无法修改.\n在弹出的小窗口输入微博登陆账号密码授权之后对话框消失,原来的页面刷新,第三方网站就可以操作你的账号.</p>\n<p>第二种方法是不在脚本中使用<code>WB2.login()</code>,而是引导用户到刚才我说的那个包含appid和回调地址的地址中去,这个地址也是会让你输入账号密码,但是这个和第一种方式的区别是这个是会离开现有的页面跳转到这个授权页中去的,输入账号密码授权之后会回到你这个链接中写的回调地址中去.</p>\n<p>以上两步的原理其实就是<code>OAuth2.0</code>协议认证的过程,只是JSSDK给你处理好了第一次请求返回的code和第二次请求返回的<code>access token</code>,因此你不需要按照官方API里面说的那样运用<code>basic</code>方式将<code>access token</code>放到<code>header</code>中使用post或者get方式等一系列你可能听不懂的名词,而只需要关注前端的逻辑,使用获得的json格式的数据即可.</p>\n<p>还是刚才那个地址,<a href="http://open.weibo.com/wiki/Weibo-JS_V2" target="_blank" rel="nofollow">微博API入口级文档说明</a>.当然”入口级”这个名词 是我自创的,你知道了这五个的用法,以后的API就可以依葫芦画瓢了.</p>\n<p>这几个API其中的<code>WB2.login()</code> 和<code>WB2.checklogin()</code>以及<code>WB2.logout</code>比较简单,是个人都能看懂,看不懂的按照我刚才说的那个<code>WB2.login()</code>方法往script标签里面一放就可以了,只是引导登陆之后你什么也没有做.</p>\n<p>登陆之后想做点什么的话(这是废话,不做什么你让人家登陆干啥),比如获取登陆新浪微博登陆用户的id,获取它的粉丝数等等,都是通过这五个入口级API的最重要的一个API\n即与微博API进行数据交互及采用Js方式调用内置微博组件的入口函数(官方是这么介绍的):<code>WB2.anyWhere(callback)</code>,</p>\n<p>然后与数据交互的话需要使用<code>W.parseCMD(uri, callback, args, opts)</code>\n其中W形参是<code>WB2.anyWhere(callback)</code>传进去的,如果想调用微博组件的话,可以使用<code>W.widget.hoverCard(…)</code>或者<code>W.widget.followButton(…);</code>等等.</p>\n<p>注意,最最重要的一步,即是你和新浪的数据交互的一步:</p>\n<p>一般<code>W.parseCMD</code>的用法是以下形式:</p>\n<pre><code class="hljs javascript"><span class="hljs-selector-tag">W</span><span class="hljs-selector-class">.parseCMD</span>(<span class="hljs-string">\'/users/show.json\'</span>, function(oResult, bStatus) {\n  <span class="hljs-selector-tag">if</span>(bStatus) {\n  <span class="hljs-comment">//to do something...</span>\n  }\n  }, {\n    <span class="hljs-attribute">screen_name </span>: <span class="hljs-string">\'姚晨\'</span>\n  }, {\n    <span class="hljs-attribute">method </span>: <span class="hljs-string">\'get\'</span>,\n    <span class="hljs-attribute">cache_time </span>: <span class="hljs-number">30</span>\n  });\n</code></pre>\n<p>其中<code>W.parseCMD()</code>的第一个参数<code>/user/show.json</code>可以换成其他的接口如:<code>/statuses/user_timeline.json</code>就可以读取这个借口的信息了,具体有哪些接口,而接口又能返回哪些数据,新浪自己给了个<a href="http://open.weibo.com/tools/apitest.php" target="_blank" rel="nofollow">微博API测试工具</a>注意:这个API测试工具的登陆界面有问题,请不要在这个页面登陆,而是先到微博首页登陆之后再在这个API测试工具的页面刷新即可.\n那个<code>screen_name</code>不是必须的,但是<code>screen_name</code>所在的{}必须保留,即使它是空的.</p>\n<p>下面的<code>method: get</code>是与后台交互时的参数,有时候的交互是需要使用<code>post</code>方式,<code>cache_time</code>看名字也知道什么意思吧?就不多说了.</p>\n<p>差不多需要注意的就这么多.</p>\n'},295:function(s,e){s.exports='<h1 id="-promise-">[译]Promise反面模式</h1>\n<p>date:   2016-03-04 22:13:35 +0800</p>\n<h3 id="-translation-">分类: [Translation]</h3>\n<hr>\n<p>最近在看<code>Promise</code>相关的东西，看到了这篇文章，觉得很不错，遂记录下来。</p>\n<p><code>Promises</code>本身是很简单的，前提是你得找得到头绪，下面是几个关于Promise的容易困惑的知识点来验证你是否真的掌握了<code>Promise</code>。其中的几个真的曾经让我抓狂过。</p>\n<h2 id="-promises"><code>嵌套Promises</code></h2>\n<p>你有一捆的Promises互相嵌套着：</p>\n<pre><code class="hljs javascript">loadSomething().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(something)</span></span> {\n    loadAnotherthing().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(another)</span></span> {\n        DoSomethingOnThem(something, another);\n        });\n    });\n</code></pre>\n<p>你这么做的原因是你需要处理这两个Promises的结果，所以你不能链式调用他们因为<code>then()</code>方法只接受上一个<code>then()</code>返回的结果。（意思是这两个<code>Promise</code>是需要同时处理没有先后关系的，但是<code>then</code>却有个先后关系，如果前者<code>throw</code> <code>error</code>直接进入<code>catch</code>处理环节）</p>\n<p>呵呵，其实你这么写的真正原因是你不知道<code>all()</code>方法：</p>\n<p>解决这种丑陋写法的方案：</p>\n<pre><code class="hljs javascript">q.<span class="hljs-built_in">all</span>([loadSomething(), loadAnotherThing()])\n    .<span class="hljs-built_in">spread</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(something, another)</span></span> {\n        DoSomethingOnThem(something, another);\n});\n</code></pre>\n<p>更简洁了。<code>q.all()</code>返回一个<code>promise</code>对象，并将这个结果结合成一个数组并传递给<code>resolve</code>方法供之后的<code>then</code>方法调用，<code>spread()</code>方法将会分割这个数组为几个数组长度的参数传递给其中的<code>DoSomethingOnThem</code>函数。</p>\n<p>（注：<code>Promise.all()</code>接受一个数组作为参数,数组元素为<code>promise</code>,元素之前没有先后顺序,同时执行,最后传递给<code>then</code>方法的值为各个<code>promise</code>方法<code>return</code>值的数组。这里作者使用的是<code>node</code>中的一个模块<code>q</code>作为示例)</p>\n<h2 id="-"><code>中断的链式调用</code></h2>\n<p>假设你有这样一段代码：</p>\n<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anAsyncCall</span><span class="hljs-params">()</span> </span>{\n    <span class="hljs-keyword">var</span> promise = doSomethingAsync();\n    promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{\n        somethingComplicated();\n    });\n    <span class="hljs-keyword">return</span> promise;\n}\n</code></pre>\n<p>这段代码的问题是，出现在<code>somethingComplicated()</code>函数的<code>error</code>都不会被捕获。<code>Promises</code>意味着能够链式调用（不然还叫什么<code>then</code>，直接<code>done</code>就行了）每一个被调用的<code>then()</code>方法返回一个新的<code>promise</code>，这个新的<code>promise</code>是会被下一个<code>then()</code>方法继续调用的。正常来说，最后一个调用应该是<code>catch()</code>方法，出现在链式调用任何地方的任何<code>error</code>都会被它捕获并处理。</p>\n<p>在上面的的代码中，链式调用在你返回第一个<code>promise</code>而不是返回一个<code>then</code>处理后的新的的<code>promise</code>给最后一个<code>then</code>调用的时候中断了（即<code>then</code>不改变原有的<code>promise</code>，它只处理它，然后返回一个新的<code>promise</code>）。\n解决这个问题的方案：</p>\n<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anAsyncCall</span><span class="hljs-params">()</span> </span>{\n    <span class="hljs-keyword">var</span> promise = doSomethingAsync();\n    <span class="hljs-keyword">return</span> promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{\n        somethingComplicated()\n    });\n}\n</code></pre>\n<p>记住，总是返回最后一个<code>then()</code>的结果（以能够使用链式调用）。</p>\n<h2 id="-"><code>混乱的集合</code></h2>\n<p>你有一组元素的数组，你想对这个数组的每个元素之执行一些异步操作。所以你发现你需要做一些涉及到递归调用的事情。</p>\n<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workMyCollection</span><span class="hljs-params">(arr)</span> {</span>\n    var resultArr = [];\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_recursive</span><span class="hljs-params">(idx)</span> {</span>\n        <span class="hljs-keyword">if</span> (idx &gt;= resultArr.<span class="hljs-built_in">length</span>) <span class="hljs-keyword">return</span> resultArr;\n        <span class="hljs-keyword">return</span> doSomethingAsync(arr[idx]).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> {</span>\n            resultArr.push(res);\n            <span class="hljs-keyword">return</span> _recursive(idx + <span class="hljs-number">1</span>);\n        });\n    }\n    <span class="hljs-keyword">return</span> _recursive(<span class="hljs-number">0</span>);\n}\n</code></pre>\n<p>额。。这段代码不是很直观，问题的关键在与，当你不知道有多长的链式调用的时候，链式调用就变成一个意见痛苦的事情。除非你知道(<code>JavaScript ES5+</code>原生的数组方法)<code>map()</code>和<code>reduce()</code></p>\n<p>解决方案：\n记住，<code>q.all</code>参数是一个由<code>promise</code>构成的数组，同时它会把结果放到一个数组中并传给<code>resolve</code>方法。我们可以简单的使用数组元素的map方法来对每个数组中的元素执行这个异步调用方法，像下面这样：</p>\n<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workMyCollection</span><span class="hljs-params">(arr)</span> </span>{\n    <span class="hljs-keyword">return</span> q.all(arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{\n        <span class="hljs-keyword">return</span> doSomethingAsync(item);\n    }));\n}\n</code></pre>\n<p>不像开始那个并不是什么解决方案的递归调用，这段代码将同步调用数组中的每个元素传递给一个异步调用函数。明显在时间上更有效率一些。\n如果你需要按顺序返回<code>promises</code>，你可以使用<code>reduce</code>：</p>\n<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workMyCollection</span><span class="hljs-params">(arr)</span></span> {\n    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(promise, item)</span></span> {\n        <span class="hljs-keyword">return</span> promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span></span> {\n            <span class="hljs-keyword">return</span> doSomethingAsyncWithResult(item, result);\n        });\n    }, q());\n}\n</code></pre>\n<p>看起来不是很简单明了，但是确实比最开始的那个简洁多了。（Not quite as tidy, but certainly tidier.）</p>\n<h2 id="-promise"><code>幽灵Promise</code></h2>\n<p>有一个确定的方法（意思是已经在开始执行Promise时就给出此方法，而不是在执行中由结果来确定的方法---译者注），有时候需要异步调用，有时候又不需要。因此你为了应对这两种情况只创建了一个promise仅仅是为了保持异步和非异步的情况下代码一致（以便于抽象和解耦---译者注），即使这种情况实际只可能出现其中一种。</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise;\n<span class="hljs-keyword">if</span> (asyncCallNeeded)\n    promise = doSomethingAsync();\n<span class="hljs-keyword">else</span>\n    promise = Q.resolve(<span class="hljs-number">42</span>);\npromise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> <span class="hljs-comment">{\n    doSomethingCool();\n}</span>);</span>\n</code></pre>\n<p>以上这段代码在反面模式中并不算最糟糕的地方，但是却应该写的更清晰一些---用<code>Q()</code>来包裹<code>value</code>或<code>promise</code>。Q()方法即接受一个值也接受一个<code>promise</code>作为参数：</p>\n<pre><code class="hljs javascript">Q(asyncCallNeeded ? doSomethingAsync() : <span class="hljs-number">42</span>)\n    .<span class="hljs-keyword">then</span>(\n    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span>{</span>\n        doSomethingGood();\n    })\n    .<span class="hljs-keyword">catch</span>(\n        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> {</span>\n            handleTheError();\n        });\n</code></pre>\n<p>备注：开始的时候我在这个情况下建议使用<code>Q.when()</code>，多亏了Kris Kowal同学在评论中的建议把我从错误中拯救出来。不要使用<code>Q.when()</code>，只使用<code>Q()</code>就够了，后者更清晰一些。</p>\n<h2 id="-"><code>饥渴的错误处理函数</code></h2>\n<p>（小节标题意思是在<code>then</code>中同时设置<code>fulfilled</code>和<code>rejected</code>，以期能够使用<code>rejected</code>函数处理同样作为<code>then</code>函数参数的<code>fulfilled</code>中的错误，但是这是不可能的，<code>fulfilled</code>中的<code>error</code>只能传递给下一个<code>then()</code>而不能在当前被<code>rejected</code>函数处理，所以这小节的标题为『过度渴望』---它虽然渴望处理错误，但是错误永远不会传递给它让他处理---译者注）</p>\n<p><code>then()</code>方法接受两个参数，对<code>fulfilled</code>状态的操作函数和对<code>rejected</code>状态操作函数。你可能写过下面这种代码：</p>\n<pre><code class="hljs javascript">somethingAsync.<span class="hljs-keyword">then</span>(\n    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {\n        <span class="hljs-keyword">return</span> somethingElseAsync();\n    },\n    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span></span> {\n        handleMyError(err);\n});\n</code></pre>\n<p>这么写的问题是，发生在<code>fulfilled</code>状态的的<code>error</code>不会传递给错误处理函数。\n解决这个问的的方法是，确保错误处理函数在一个独立的then方法中：</p>\n<pre><code class="hljs javascript">somethingAsync\n    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {\n        <span class="hljs-keyword">return</span> somethingElseAsync();\n    })\n    .<span class="hljs-keyword">then</span>(null,\n        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span></span> {\n            handleMyError(err);\n        });\n</code></pre>\n<p>或者使用<code>catch()</code>：</p>\n<pre><code class="hljs javascript">somethingAsync\n    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>\n        <span class="hljs-keyword">return</span> somethingElseAsync();\n    })\n    .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> {</span>\n        handleMyError(err);\n    });\n</code></pre>\n<p>这样可以确保任何发生在链式调用中的<code>error</code>都能得到处理。</p>\n<h2 id="-promise"><code>被遗忘的Promise</code></h2>\n<p>你调用一个方法，返回一个<code>promise</code>，然而你忘记了这个<code>promise</code>，然后又创建了一个<code>promise</code>：</p>\n<pre><code class="hljs javascript">var <span class="hljs-keyword">deferred</span> = Q.defer();\ndoSomethingAsync().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span></span> {\n    res = manipulateMeInSomeWay(res);\n    <span class="hljs-keyword">deferred</span>.resolve(res);\n}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span></span> {\n    <span class="hljs-keyword">deferred</span>.reject(err);\n});\n\n<span class="hljs-keyword">return</span> <span class="hljs-keyword">deferred</span>.promise;\n</code></pre>\n<p>这段代码真的是把<code>promsie</code>的简洁特性抛弃的一干二净---有太多无用的代码了。\n解决方案是，仅仅返回<code>promise</code>即可：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">return</span> doSomethingAsync().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span></span> {\n    <span class="hljs-keyword">return</span> manipulateMeInSomeWay(res);\n});\n</code></pre>\n'},296:function(s,e){s.exports='<h1 id="git-">git常用命令总结</h1>\n<p>date:   2016-04-21 22:13:35 +0800</p>\n<h3 id="-vcs-">分类: [VCS]</h3>\n<hr>\n<p>经常使用git，但是一直没时间写，现在终于有时间了，所以总结一下常用命令。</p>\n<p>新建一个分支并切换到这个分支：</p>\n<pre><code class="hljs javascript">git checkout -<span class="hljs-selector-tag">b</span> branch_name\n</code></pre>\n<p>切换分支:</p>\n<pre><code class="hljs javascript"><span class="hljs-attribute">git</span> checkout branch_name\n</code></pre>\n<p>删除一个分支(需要先<code>checkout</code>到另一个分支):</p>\n<pre><code class="hljs javascript"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-d <span class="hljs-keyword">branch_name</span>\n</code></pre>\n<p>注意，如果你在本地新建一个分支，而没有<code>git push</code>的话，执行下列命令删除一个分支会提示你</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">error: </span>The branch \'test\' is not fully merged.\nIf you are sure you want to delete it, run \'git branch -D test\'.\n</code></pre>\n<p>确定不要的话，按说明强制删除即可。</p>\n<p>提交文件的流程是:</p>\n<pre><code class="hljs javascript">git <span class="hljs-keyword">add</span> ==&gt; git commit ==&gt; git <span class="hljs-keyword">push</span>\n</code></pre>\n<p><code>git add</code>常用的有三个参数:</p>\n<ol>\n<li><code>git add -A</code> 所有变动记录都增加到暂存区，不管是新增还是删除还是修改。</li>\n<li><code>git add .</code> 文件的增加记录，修改添加到暂存区，不包括删除的文件。</li>\n<li><code>git add -u</code> 文件的删除和修改记录添加到暂存区，不包括新增的文件。</li>\n</ol>\n<p>人生没有后悔药，但是<code>git</code>有，如果不小心提交了错误的文件或者提交信息写错了，可以根据情况执行以下命令。</p>\n<p>首先<code>git status</code> 查看版本状态，(我用<code>zsh</code>)红色文件表示未<code>git add</code>到暂存区，绿色文件表示已经<code>git add</code>到缓存区，等待<code>git commit</code>。</p>\n<p>这个时候如果不想<code>git add</code>到缓存区的话，那就<code>git reset HEAD</code>全部将文件重新变为未<code>git add</code>的原始状态，如果只是不想<code>git add</code>某一个文件到缓存区的话, 需要指定文件名:</p>\n<pre><code class="hljs javascript">git <span class="hljs-keyword">reset</span> <span class="hljs-keyword">HEAD</span> filename\n</code></pre>\n<p>有时候不但不想把修改过的文件<code>git add</code>到缓存区，而且想把这个文件所做的修改都忽略掉，也即回复到未修改的状态，那重新检出即可:</p>\n<pre><code class="hljs javascript">git checkout <span class="hljs-comment">-- filename</span>\n</code></pre>\n<p>注意这里没有拼写错误,<code>checkout</code>和<code>filename</code>之间有左右存在一个空格的短横线。</p>\n<p><code>git add</code>之后就是<code>git commit</code>，可以跟一个参数<code>-m</code>来写下提交说明，这是个好习惯，而且是被强制的，如果没有<code>-m</code>参数，则会进入一个<code>vim</code>编辑状态，提示你加上信息:</p>\n<pre><code class="hljs javascript"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">\'这是一个提交说明\'</span>\n</code></pre>\n<p>这个时候发现提交说明写错了，不想<code>commit</code>了（此时<code>HEAD</code>已经变了），两个方法：</p>\n<p>一个是移除<code>commit</code>：（因为这个还没有<code>push</code>，只是<code>commit</code>到本地仓库）</p>\n<p>首先<code>git log</code>，记下你误<code>commit</code>之前的一个<code>commit id</code>，是一个<code>hash(SHA)</code>，如：<code>73cf3bfc3419a85e959d7ecfcb917d9cdc24b3c9</code>或者直接是最近的一次<code>push</code>的<code>HEAD</code>也行：</p>\n<pre><code class="hljs javascript">git reset <span class="hljs-number">73</span>cf<span class="hljs-number">3</span>bfc<span class="hljs-number">3419</span>a<span class="hljs-number">85e959</span>d<span class="hljs-number">7</span>ecfcb<span class="hljs-number">917</span>d<span class="hljs-number">9</span>cdc<span class="hljs-number">24</span>b<span class="hljs-number">3</span><span class="hljs-keyword">c</span><span class="hljs-number">9</span>\n</code></pre>\n<p>（这个时候不能像<code>git add</code>的时候使用<code>git reset HEAD</code>了因为<code>git commit</code>之后<code>HEAD</code>已经变了(即已经可以通过<code>git log</code>查看提交记录了)）</p>\n<p>这里插一句<code>git reset</code>命令的三个参数:<code>--mixed</code>,<code>--soft</code>,<code>--hard</code>:</p>\n<p>网上的教程一大堆，又是画图说明又是引用官方分支说明的，麻烦，我说的简单点。</p>\n<blockquote>\n<p>简单的，举例子的方式简单点。 ---Xheldon</p>\n</blockquote>\n<p><code>git reset</code>默认是<code>mixed</code>参数，即执行<code>git reset xxxx</code>（xxx表示一个<code>SHA</code>或者未<code>commit</code>的时候是<code>HEAD</code>） 即是执行<code>git reset --mixed xxxx</code>, 他的作用是将文件恢复到你修改过文件之后没有执行任何<code>git</code>命令的状态(文件是红色状态)。</p>\n<p><code>--soft</code>参数是将文件仅仅是恢复到未commit的状态，其文件还是<code>git add</code>过的（还是绿的）。</p>\n<p><code>--hard</code>就比较强势了，它会将你的文件彻底恢复到你指定的提交记录的状态，不管你是<code>add</code>过还是<code>commit</code>过还是修改过文件，统统无视。注意，执行<code>git reset --hard xxx</code>具有一定的危险性，会将你当前的修改从本机删除。</p>\n<p><code>git reset --hard xxx</code>之后，文件已经从本机删除了，你所有的修改也已经被删除，但是想找回<code>hard</code>删除的文件修改记录怎么办呢？使用<code>git reflog</code></p>\n<p>你的每一步<code>commit</code>和<code>reset</code>操作，<code>git</code>都会生成一个记录，这个记录可以在通过<code>git reflog</code>找到，在每个记录之前有个短<code>hash</code>，复制这个短<code>hash</code>，重新执行一遍<code>git reset --hard short_hash</code>即可。</p>\n<p>注意，执行<code>git commit</code>之后这个时候的<code>HEAD</code>已经变成你提交过的文件的更改状态，再执行<code>git reset --mixed HEAD</code>或者<code>git  reset --soft HEAD</code>无效（因为当前的<code>HEAD</code>就是你<code>commit</code>之后的那个点（即使你没有<code>push</code>）），如果想返回到<code>git add</code>之后，<code>git commit</code>之前的状态需要<code>git reset --soft commit_id</code>，如果返回到<code>git add</code>之前的状态，需要<code>git reset --mixed commit_id</code>， 或者直接<code>git reset commit_id</code>。 </p>\n<p><code>git commit</code>后悔药的另一牌子叫<code>--amend</code>，提交之后，后悔了，发现msg写错了，或者文件又修改了，不想再生成一条<code>commit</code>记录因为很丑而且显得你很菜，居然会犯这种提交信息写错的低级错误，那么运行：</p>\n<pre><code class="hljs javascript"><span class="hljs-string">git </span><span class="hljs-string">commit </span><span class="hljs-built_in">--amend</span> <span class="hljs-string">change_file_name_after_commit </span>-m <span class="hljs-string">"新的msg"</span>\n</code></pre>\n<p>即可。</p>\n<p>后悔药吃过了，<code>git commit</code>之后确认无误就可以<code>git push</code>了。这个时候如果你当前分支所分出来的远程分支没有其他人提交更新的话，你就可以使用<code>fast forward</code> 模式，中文翻译成快进模式，直接合并进去。形象的查看合并情况可以使用：</p>\n<pre><code class="hljs javascript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--graph --pretty=oneline</span>\n</code></pre>\n<p>如果在你分出分支期间，还有其他人也提交了分支，如果没有冲突的话那也可以直接合并，需要你先<code>git pull</code>下来，再执行<code>git push</code>。\n如果有冲突的话这个时候会提示你别人的修改和你的修改有什么冲突，这个就需要你手动解决，解决完之后就<code>git add</code>, <code>git commit</code>即可。</p>\n<p>合并分支：</p>\n<pre><code class="hljs javascript">git <span class="hljs-keyword">merge</span> another_branch_name\n</code></pre>\n<p>这里的情况是<code>非fast forward</code>模式，即B从A分支上分出后，作为父分支的A分支又改变了，B分支这个时候也改了点东西，再想合并回A分支的时候，就出现了现在的情况以下情况：\n注意，假设你在A分支上，需要<code>merge</code>的是B分支，则<code>merg</code>过来的B分支必须是<code>git push</code>过的，如果B分支只<code>git commit</code>的分只是不会被merge的。因为<code>git merge branch_name</code>的<code>branch_name</code>是从<code>branch_name</code>的远程<code>origin</code>来<code>merge</code>的，<code>commit</code>只修改了本地的<code>HEAD</code>，没有<code>push</code>就没有修改远程<code>origin</code>。\n假设B分支已经<code>git push</code>了自己的改动到远程，而本地A也<code>git add</code>了自己的改动到本地仓库，则在A分支上执行<code>git merge B</code>的时候会出现(假设改动的是<code>config.js</code>):</p>\n<pre><code class="hljs javascript">Updating 474cfbf..9c94d0c\n<span class="hljs-keyword">error: </span>Your local changes to the following files would be overwritten by merge:config.js\nPlease commit your changes or stash them before you merge.\nAborting\n</code></pre>\n<p>意思就是合并两个分支的时候出错中断。会让你先暂存你的当前分支的修改即<code>git stash</code>或者提交你的修改即<code>git commit</code>。 之后<code>git merge</code>之后，出现冲突再手动修改，重新提交。\nOK，我们先<code>git commit</code>当前的修改，再次执行<code>git merge B</code>，这个时候出现（假设冲突文件是<code>config.js</code>）：</p>\n<pre><code class="hljs javascript">Auto-merging config.js\nCONFLICT (content): <span class="hljs-keyword">Merge</span> conflict <span class="hljs-keyword">in</span> config.js\n<span class="hljs-keyword">Automatic</span> <span class="hljs-keyword">merge</span> <span class="hljs-keyword">failed</span>; fix conflicts and then <span class="hljs-keyword">commit</span> the result.\n</code></pre>\n<p>手动解决之后,再重新<code>git add</code>，<code>git commit</code>即可。</p>\n<p>注意，如果你在一个分支上修改了文件，而在<code>checkout</code>到另一个分支的时候没有发生冲突，则不会有任何提示，文件改动依然存在，因此你可以将文件在一个分支上改动后，再提交到另一个分支上。而如果在一个分支上改动文件之后，再<code>checkout</code>其他分支出现冲突的话(比如其他分支<code>git pull</code>了，或者其他分支<code>git commit</code>了相同文件的相同修改):</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">error: </span>Your local changes to the following files would be overwritten by checkout:\n    config.js\nPlease commit your changes or stash them before you switch branches.\nAborting\n</code></pre>\n<p>这个时候就需要你先<code>git stash</code>储藏（此<code>stash储藏</code>不是<code>git add暂存</code>，<code>stash</code>是先将文件放到一个特定的区域，等到切换完分支之后，再像一个补丁一样，应用这个<code>stash</code>到切换到的<code>checkout</code>分支，或者不应用<code>stash</code>，等切换的分上的事情做完之后，再切换回来的时候，再次应用这个<code>stash</code>，当然如果你一直不想应用你的<code>stash</code>也可以一直不应用，没有关系）.\n这里说到了<code>git stash</code>，这个命令的使用场景是同时需要做两个分支的修改的时候，其中一个分支做到了一半，这个时候另一个分支也需要修改，你不可能把已经做一半的内容丢弃，又不能<code>commit</code>，因为这有可能在<code>checkout</code>过去的会造成<code>conflict</code>，因此你需要储藏<code>stash</code>：\n先查看当前状态，<code>git status</code>：</p>\n<pre><code class="hljs javascript">On branch <span class="hljs-keyword">optimize</span>\nYour branch <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-<span class="hljs-built_in">date</span> <span class="hljs-keyword">with</span> <span class="hljs-string">\'origin/optimize\'</span>.\nChanges <span class="hljs-keyword">not</span> staged <span class="hljs-keyword">for</span> <span class="hljs-keyword">commit</span>:\n  (<span class="hljs-keyword">use</span> <span class="hljs-string">"git add &lt;file&gt;..."</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will be committed)\n  (<span class="hljs-keyword">use</span> <span class="hljs-string">"git checkout -- &lt;file&gt;..."</span> <span class="hljs-keyword">to</span> discard changes <span class="hljs-keyword">in</span> working <span class="hljs-keyword">directory</span>)\n\n    modified:   config.js\n\n<span class="hljs-keyword">no</span> changes added <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span> (<span class="hljs-keyword">use</span> <span class="hljs-string">"git add"</span> <span class="hljs-keyword">and</span>/<span class="hljs-keyword">or</span> <span class="hljs-string">"git commit -a"</span>)\n</code></pre>\n<p>储存一下,<code>git stash</code>:</p>\n<pre><code class="hljs javascript">Saved working directory and index state WIP on <span class="hljs-keyword">optimize</span>: <span class="hljs-number">24</span>bf0e1 <span class="hljs-keyword">test</span> <span class="hljs-keyword">add</span>\n<span class="hljs-keyword">HEAD</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">now</span> <span class="hljs-keyword">at</span> <span class="hljs-number">24</span>bf0e1 这是一个提交\n</code></pre>\n<p>之后再<code>git status</code>看下:</p>\n<pre><code class="hljs javascript">On branch <span class="hljs-keyword">optimize</span>\nYour branch <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-<span class="hljs-built_in">date</span> <span class="hljs-keyword">with</span> <span class="hljs-string">\'origin/optimize\'</span>.\n<span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean \n</code></pre>\n<p>这个时候可以放心的切换到其他分支，这里要说明的是，切换到其他分支的时候你也可以使用储藏的分支到当前分支（只要你不怕冲突），查看储藏列表,<code>git stash list</code>:</p>\n<pre><code class="hljs javascript">stash@{<span class="hljs-number">0</span>}: WIP <span class="hljs-keyword">on</span> optimize: <span class="hljs-number">24</span>bf0e1 test add\n</code></pre>\n<p>这是刚刚<code>stash</code>起来的改动，可以使用<code>git stash apply</code>应用这个最近的改动，如果<code>stash</code>的改动有好几个，那就指定<code>stash</code>的名字:</p>\n<pre><code class="hljs javascript">git stash <span class="hljs-built_in">apply</span> stash@{<span class="hljs-number">0</span>}\n</code></pre>\n<p>应用之后就会从储存区删除这个<code>stash</code>，如果不希望的删除的话就：</p>\n<pre><code class="hljs javascript">git stash apply stash_name <span class="hljs-comment">--index</span>\n</code></pre>\n<p>之后再希望删除的话就：</p>\n<pre><code class="hljs javascript">git stash <span class="hljs-built_in">drop</span> stash_name\n</code></pre>\n<p>以上两个命令不带<code>stash_name</code>的话默认删除最近的一个<code>stash</code>。</p>\n<p>暂时能想到的就这么多吧，如果不熟悉，还是用<code>Sourcetree</code>吧。</p>\n<h2 id="-">更新</h2>\n<p><code>git revert/reset/rebase</code> 只看说明是搞不懂的, 需要你自己输入命令测试一下. </p>\n<p>我就喜欢为了干净整洁的提交历史而视同 <code>git rebase</code>, 但是这个命令很危险, 有一些使用场景需要注意. 而比 <code>git rebase</code> 更危险的是 <code>git reset</code>, 它会把当前项目重置到某一次提交. 而 <code>git revert</code> 就相对安全一些, 但是你想 <code>revert</code> 之前的某个提交最好需要保证你的缓存区是空的, 否则会遇到错误提示. </p>\n<p>当然, <code>git</code> 命令千千万(夸张), 有一些命令是针对一些特殊场景的, 在没遇到之前可能无法理解其中的一些用法, 这个很正常.</p>\n<p>比如 <code>git reset commitId</code> 即是把 <code>HEAD</code> 移动到 <code>commitId</code> 所在的地方, 你可能一头雾水, 移动 <code>HEAD</code> 有什么用? 这个命令的目的是什么? 再比如 <code>git revert commitId</code> 是把 <code>commitId</code> 的提交给移除, 而不移动 <code>HEAD</code> 的指针. </p>\n<p>看代码(<code>d0b9def</code> 对应 <code>commit -m &#39;reset/revert test 3&#39;</code> 这个提交, 当前 <code>HEAD</code> 在 <code>&#39;reset/revert test 4&#39;</code>上): </p>\n<p><code>git revert d0b9def</code> 之后, 你的代码可能是这个样子的:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">reset</span>/revert <span class="hljs-keyword">test</span> <span class="hljs-number">1</span>\n<span class="hljs-keyword">reset</span>/revert <span class="hljs-keyword">test</span> <span class="hljs-number">2</span>\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-keyword">HEAD</span>\n<span class="hljs-keyword">reset</span>/revert <span class="hljs-keyword">test</span> <span class="hljs-number">3</span>\n<span class="hljs-keyword">reset</span>/revert <span class="hljs-keyword">test</span> <span class="hljs-number">4</span>\n=======\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="hljs-keyword">parent</span> <span class="hljs-keyword">of</span> d0b9def... <span class="hljs-keyword">reset</span>/revert <span class="hljs-keyword">test</span>\n</code></pre>\n<p>在相同的 <code>HEAD</code> 上执行 <code>git reset d0b9def</code> 之后, 你的工作区可能是这个样子的:</p>\n<pre><code class="hljs javascript"> <span class="hljs-built_in">reset</span>/<span class="hljs-built_in">revert</span> test <span class="hljs-number">1</span>\n <span class="hljs-built_in">reset</span>/<span class="hljs-built_in">revert</span> test <span class="hljs-number">2</span>\n <span class="hljs-built_in">reset</span>/<span class="hljs-built_in">revert</span> test <span class="hljs-number">3</span>\n+<span class="hljs-built_in">reset</span>/<span class="hljs-built_in">revert</span> test <span class="hljs-number">4</span>\n</code></pre>\n<p>看出移动不移动 <code>HEAD</code> 的区别了吧? <code>revert</code> 一定会让你手动解决冲突, 因为其保留的是从你 <code>commitId</code> 之前的一个父 <code>commit</code> 到当前 <code>HEAD</code> 的除了 <code>d0b9def</code> 的所有变动. 而 <code>reset</code> 不会让你解决冲突, 而是默默的移动 <code>HEAD</code> 把自 <code>d0b9def</code> 以来所有的变动都显示为文件改动, 需要你手动 <code>git add/commit</code> 一下, 当然少不了 <code>push --force</code>.</p>\n<p>因此, <code>revert</code> 被设计为撤销<code>公开</code>的提交的安全方式，<code>reset</code> 被设计为重设<code>本地</code>更改。因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销。</p>\n'},297:function(s,e){s.exports='<h1 id="vue-webpack-">Vue + Webpack 组件式开发(练习环境)</h1>\n<p>date:   2016-04-30 22:13:35 +0800</p>\n<h3 id="-vue-framework-">分类: [Vue,Framework]</h3>\n<hr>\n<h2 id="-">前言</h2>\n<p>研究了下别人的 <code>vue</code> 多页面框架, 都是直接复制 <code>package.json</code> 文件,然后在本地 <code>npm install</code> 一下即可, 或者使用官网 <code>vue-cli</code> 工具生成一个项目, 觉得这样虽然看的懂, 但是记不住, 因此有必要从零开始搭建一个使用 <code>.vue</code> 作为组件的项目练习一下, 因此有了这个项目.</p>\n<p>既然使用了 <code>.vue</code> 组件, 就不能像之前使用 <code>jQuery</code> 一样把 <code>vue.js</code> 引入页面中, 而是使用配套的 <code>webpack</code> + <code>babel</code> + 各种 <code>loader</code> 工具编译 <code>.vue</code> 文件, 再打包生成 <code>html</code>.</p>\n<h2 id="fbi-warning">FBI warning</h2>\n<p><em><code>切记</code></em> : 因为是最基本的初体验, 所以一些正式开发中必装的 <code>loader</code> 和 <code>plugin</code> 就没有装, 因为只是想按照官方教程手动敲出来加深印象, 特别是进阶教程中比较麻烦的父子组件传参, 作用域插槽, 递归组件以及 <code>slot</code> 等. 因此这个配置不可能作为正式开发的参照配置, 只可作为了解 <code>vue</code> 组件工作原理的练手项目.</p>\n<h2 id="-">配置说明</h2>\n<p>以下配置的详细说明在后面可以找到, 不想看的话直接复制下面的 <code>package.json</code> 即可, 但是为了加深印象还是建议手动敲一遍. </p>\n<p>废话不多说, 开始.</p>\n<p>首先, 既然是 <code>webpack+vue</code>, 那相应的安装包少不了, 这里我们使用 <a href="mailto:`vue@2.2.4">`vue@2.2.4</a><code>和</code><a href="mailto:webpack@1.12.2">webpack@1.12.2</a>`: </p>\n<pre><code class="hljs javascript">npm install webpack@<span class="hljs-number">1.12</span><span class="hljs-number">.2</span> vue@<span class="hljs-number">2.2</span><span class="hljs-number">.4</span> --save-dev\n</code></pre>\n<p>然后是 <code>babel</code> 和相应的 <code>loader</code>, 这里我们使用 <code>es2015</code> 这个配置, 用最新的就好:</p>\n<pre><code class="hljs javascript">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">babel </span><span class="hljs-keyword">bebel-core </span><span class="hljs-keyword">babel-loader </span><span class="hljs-keyword">babel-preset-es2015 </span>--save-dev\n</code></pre>\n<p>然后是 <code>webpack</code> 的必装 <code>loader</code>, <code>css-loader</code> 用来处理 <code>css</code> 中 <code>url()</code> 的资源, <code>style-loader</code> 用来将 <code>require</code> 的 <code>css</code> 抽出放到 <code>style</code> 标签中, 然后加到页面 <code>head</code> 部分. <code>html-webpack-plugin</code> 用来将入口文件 <code>js</code> 变成 <code>html</code>, 入口文件中的各种资源由各种 <code>loader</code> 处理后插入到它生成的 <code>html</code> 中, <code>extract-text-webpack-plugin</code> 用来将被 <code>js</code> 通过 <code>style</code> 标签 <code>append</code> 到 <code>head</code> 中的样式抽出到单独的 <code>.css</code> 文件中:</p>\n<pre><code class="hljs javascript">npm <span class="hljs-keyword">install</span> css-loader <span class="hljs-keyword">style</span>-loader html-webpack-<span class="hljs-keyword">plugin</span> <span class="hljs-keyword">extract</span>-<span class="hljs-built_in">text</span>-webpack-<span class="hljs-keyword">plugin</span>@<span class="hljs-number">1.0</span><span class="hljs-number">.1</span> <span class="hljs-comment">--save-dev</span>\n</code></pre>\n<p>然后是 <code>vue</code> 相关的东西, 因为一个 <code>.vue</code> 里面有至少有三个标签 <code>template/style/script</code>, 因此需要三个 <code>loader</code> 来处理, 再加上一个总的 <code>vue-loader</code>, 就是四个 <code>loader</code> ,这里: </p>\n<p><code>vue-html-loader</code> 是 <code>webpack</code> 的官方 <code>html-loader</code> 的 <code>fork</code>, 作者放到这里只是为了能在 <code>webpack.config.js</code> 中的 <code>module.export.vue</code> 对象上使用 <code>html</code> 选项来单独配置 <code>vue</code> 的 相关 <code>html</code>(本项目安装 <code>vue-loader</code> 即可, 这里只是顺带安装说明一下);</p>\n<p><code>vue-style-loader</code> 用来处理 <code>.vue</code> 文件中 <code>style</code> 中的内容, 是 <code>webpack</code> 的官方 <code>style-loader</code> 的 <code>fork</code>(本项目安装 <code>vue-loader</code> 即可, 这里只是顺带安装说明一下);</p>\n<p><code>vue-template-compiler</code> 用来处理 <code>.vue</code> 文件中 <code>template</code> 中的内容, 除非是用它编译后的文件做其他事情才需要单独配置(即写 <code>build tools</code>, 否则这个不是必须的, 因为 <code>vue-loader</code> 已经默认使用它了)(本项目安装 vue-loader 即可, 这里只是顺带安装说明一下);</p>\n<p><code>vue-loader</code> 用来处理 <code>.vue</code> 后缀的内容, 在遇到相关的内容时, 会调用上述三个相关的 <code>loader</code> 来处理.</p>\n<pre><code class="hljs javascript">npm <span class="hljs-keyword">install</span> vue-html-loader vue-loader vue-<span class="hljs-keyword">style</span>-loader vue-<span class="hljs-keyword">template</span>-compiler <span class="hljs-comment">--save-dev</span>\n</code></pre>\n<p>最后就是开发用的 <code>webpack-dev-server</code>, 这里我们安装 <code>1.12.1</code> 版本:</p>\n<pre><code class="hljs javascript">npm install webpack-<span class="hljs-built_in">dev</span>-server --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span>\n</code></pre>\n<p>下面是总的 <code>package.json</code> 配置文件, 而具体的每个 <code>package.json</code> 字段的含义, 可以查看<a href="http://json.is/" target="_blank">这个网站</a>,</p>\n<pre><code class="hljs javascript">{\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"vue-components"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,\n  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"vue components test"</span>,\n  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"app/app.js"</span>,\n  <span class="hljs-attr">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"webpack-dev-server --hot"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"webpack"</span>\n  },\n  <span class="hljs-attr">"keywords"</span>: [\n    <span class="hljs-string">"vue"</span>,\n    <span class="hljs-string">"components"</span>\n  ],\n  <span class="hljs-attr">"author"</span>: <span class="hljs-string">"xheldon"</span>,\n  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"MIT"</span>,\n  <span class="hljs-attr">"dependencies"</span>: {\n    <span class="hljs-attr">"vue"</span>: <span class="hljs-string">"^2.2.4"</span>\n  },\n  <span class="hljs-attr">"devDependencies"</span>: {\n    <span class="hljs-attr">"babel"</span>: <span class="hljs-string">"^6.23.0"</span>,\n    <span class="hljs-attr">"babel-core"</span>: <span class="hljs-string">"^6.24.0"</span>,\n    <span class="hljs-attr">"babel-loader"</span>: <span class="hljs-string">"^6.4.1"</span>,\n    <span class="hljs-attr">"babel-preset-es2015"</span>: <span class="hljs-string">"^6.24.0"</span>,\n    <span class="hljs-attr">"css-loader"</span>: <span class="hljs-string">"^0.27.3"</span>,\n    <span class="hljs-attr">"extract-text-webpack-plugin"</span>: <span class="hljs-string">"^1.0.1"</span>,\n    <span class="hljs-attr">"html-webpack-plugin"</span>: <span class="hljs-string">"^2.28.0"</span>,\n    <span class="hljs-attr">"style-loader"</span>: <span class="hljs-string">"^0.16.0"</span>,\n    <span class="hljs-attr">"vue-html-loader"</span>: <span class="hljs-string">"^1.2.4"</span>,\n    <span class="hljs-attr">"vue-loader"</span>: <span class="hljs-string">"^11.3.1"</span>,\n    <span class="hljs-attr">"vue-style-loader"</span>: <span class="hljs-string">"^2.0.4"</span>,\n    <span class="hljs-attr">"vue-template-compiler"</span>: <span class="hljs-string">"^2.2.4"</span>,\n    <span class="hljs-attr">"webpack"</span>: <span class="hljs-string">"^1.12.2"</span>,\n    <span class="hljs-attr">"webpack-dev-server"</span>: <span class="hljs-string">"^1.12.1"</span>\n  }\n}\n</code></pre>\n<h2 id="-">项目说明</h2>\n<p>Ok, 依赖安装完了, 接下来看下 <code>webpack</code> 配置, 因为是想尽快测试 <code>vue</code> 官方文档的组件部分, 所以一切从简了:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>);\n<span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'webpack\'</span>);\n<span class="hljs-keyword">var</span> HtmlwebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'html-webpack-plugin\'</span>); \n\n<span class="hljs-comment">// 常用配置,项目较小不抽出了</span>\n<span class="hljs-keyword">var</span> ROOT_PATH = path.resolve(__dirname);<span class="hljs-comment">//根路径</span>\n<span class="hljs-keyword">var</span> APP_PATH = path.resolve(ROOT_PATH, <span class="hljs-string">\'app\'</span>);<span class="hljs-comment">//开发路径</span>\n<span class="hljs-keyword">var</span> BUILD_PATH = path.resolve(ROOT_PATH, <span class="hljs-string">\'build\'</span>);<span class="hljs-comment">//输出路径</span>\n<span class="hljs-keyword">var</span>  ExtractTextPlugin= <span class="hljs-built_in">require</span>(<span class="hljs-string">\'extract-text-webpack-plugin\'</span>);\n\n<span class="hljs-built_in">module</span>.exports = {\n  entry: {\n    app: path.resolve(APP_PATH, <span class="hljs-string">\'app.js\'</span>)\n  },\n  output: {\n    path: BUILD_PATH,\n    filename: <span class="hljs-string">\'bundle.js\'</span><span class="hljs-comment">//因为只有一个入口文件, 因此直接写死了</span>\n  },\n  resolve: {\n    alias: {\n      <span class="hljs-comment">//注意, 这里导入的是/node_module/vue/dist/vue.js, 跟 vue-router.js 的不同</span>\n      vue: <span class="hljs-string">\'vue/dist/vue.js\'</span>\n    }\n  },\n  <span class="hljs-comment">//开启 dev source map</span>\n  devtool: <span class="hljs-string">\'eval-source-map\'</span>,\n  <span class="hljs-comment">//开启 dev server</span>\n  devServer: {\n    historyApiFallback: <span class="hljs-literal">true</span>,\n    hot: <span class="hljs-literal">true</span>,<span class="hljs-comment">//HMR</span>\n    inline: <span class="hljs-literal">true</span>,\n    progress: <span class="hljs-literal">true</span>\n  },\n  <span class="hljs-keyword">module</span>: {\n    loaders:[\n      {\n        test: <span class="hljs-regexp">/\\.vue$/</span>,\n        loader: <span class="hljs-string">\'vue\'</span>\n      },\n      {\n        test: <span class="hljs-regexp">/\\.css$/</span>,\n        loader: ExtractTextPlugin.extract(<span class="hljs-string">\'css-loader\'</span>)\n      },\n      {\n        test: <span class="hljs-regexp">/\\.js$/</span>,\n        loader: <span class="hljs-string">\'babel\'</span>,\n        include: ROOT_PATH,\n        exclude: <span class="hljs-regexp">/node_modules/</span>\n      },\n      {\n        test: <span class="hljs-regexp">/\\.html$/</span>,\n        loader: <span class="hljs-string">\'vue-html\'</span>\n      }\n    ]\n  },\n  vue:{\n    loaders: {\n      css: ExtractTextPlugin.extract(<span class="hljs-string">\'css-loader\'</span>)    }\n  },\n  plugins:[\n    <span class="hljs-keyword">new</span> HtmlwebpackPlugin({\n      title: <span class="hljs-string">\'Vue component test\'</span>,\n      filename: <span class="hljs-string">\'this_is_final_filename_address_you_visit_in_browser.html\'</span>,<span class="hljs-comment">//生成的最终文件名</span>\n      template: <span class="hljs-string">\'app/this_is_main_page_which_you_put_components_into.html\'</span>,<span class="hljs-comment">//放置组件的地方, 一般是一个 body 下一个孤零零的 app 标签即可.</span>\n      inject: <span class="hljs-literal">true</span>\n    })\n  ]\n};\n</code></pre>\n<p>关于这个配置, 有点东西需要说一下.</p>\n<p>从上往下, 首先是 <code>alias</code> , 使用过 <a href="https://github.com/vuejs/vue-router/" target="_blank"> <code>vue-router</code> </a> 的人可能不需要这个配置, 但是使用 <code>.vue</code> 组件的项目必须这个配置,因为需要指定使用的 <code>vue</code> 的 <code>js</code> 类型, 看下本项目下 <code>node_module/vue/dist/</code> 文件夹下的文件, 有 <code>vue.js</code> 和 <code>vue.common.js</code> 两种, 其中 <code>vue</code> 编译 <code>template</code> 组件的时候是需要一个 <code>compiler.js</code> 的, 目的是把 <code>template</code> 中的 <code>html</code> 内容编译成 <code>render</code> 函数:</p>\n<p>编译前:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n  Hello </span><span class="hljs-template-variable">{{who}}</span><span class="xml">\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">\n  <span class="hljs-keyword">new</span> Vue({\n    el: <span class="hljs-string">\'#app\'</span>,\n    data: {who: <span class="hljs-string">\'Vue\'</span>}\n  })\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n</code></pre>\n<p>编译后:</p>\n<pre><code class="hljs javascript"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">\n  <span class="hljs-keyword">new</span> Vue({\n    el: <span class="hljs-string">\'#app\'</span>,\n    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{\n      <span class="hljs-keyword">with</span> (<span class="hljs-keyword">this</span>) {\n        __h__(<span class="hljs-string">\'div\'</span>,\n          {staticAttrs:{<span class="hljs-string">"id"</span>:<span class="hljs-string">"app"</span>}},\n          [(<span class="hljs-string">"\\n  Hello "</span>+__toString__(who)+<span class="hljs-string">"\\n"</span>)],\n          <span class="hljs-string">\'\'</span>\n        )\n      }\n    },\n    data: {who: <span class="hljs-string">\'Vue\'</span>}\n  })\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>而 <code>vue</code> 使用 <code>compiler</code> 编译 <code>template</code> 后的 <code>js</code> 在运行的时候发现有 <code>render</code> 函数的话就直接执行 <code>render</code>, <code>template</code> 字段下的内容会被忽略. 而执行编译后的 <code>render</code> 的任务,是由 <code>vue.common.js</code> 完成的.因此:</p>\n<pre><code class="hljs javascript">vue<span class="hljs-selector-class">.js</span> = vue<span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.js</span> + compiler.js\n</code></pre>\n<p>所以, 如果你使用的是 <code>vue-router</code>, 它的 <code>package.json</code> 中的 <code>main</code> 字段是指向 <code>node_module/dist/vue.common.js</code> 的, 如果你直接复制这个到你的项目下, 运行的时候会提示你类似于 <code>vue.common.js</code> 的 <code>runtime</code> 错误之类的信息.</p>\n<p>其次需要说的是这个 <code>css-loader</code> 和 <code>style-loader</code> 以及 <code>vue-style-loader</code>, 有了 <code>style-loader</code> 为何还要个 <code>vue-style-loader</code> 呢? 看了下 <code>vue-style-loader</code> 的说明, 明白了其仅仅是一个 <code>style-loader</code> 的 <code>fork</code>, 但是为了单独处理 <code>.vue</code> 文件, 同时为了让用户配置 <code>vue</code> 更清晰, 将其加到了 <a href="mailto:`webpack@1.x">`webpack@1.x</a><code>的配置文件中的</code>vue<code>字段中. 可以通过将</code>extract-text-webpack-plugin` 插件的配置从:</p>\n<pre><code class="hljs javascript"><span class="hljs-selector-tag">vue</span>:{\n  <span class="hljs-attribute">loaders</span>: {\n    css: ExtractTextPlugin.<span class="hljs-built_in">extract</span>(<span class="hljs-string">\'vue-style-loader\'</span>,<span class="hljs-string">\'css-loader\'</span>)\n  }\n}\n</code></pre>\n<p>改成:</p>\n<pre><code class="hljs javascript"><span class="hljs-selector-tag">vue</span>:{\n  <span class="hljs-attribute">loaders</span>: {\n    css: ExtractTextPlugin.<span class="hljs-built_in">extract</span>(<span class="hljs-string">\'style-loader\'</span>,<span class="hljs-string">\'css-loader\'</span>)\n  }\n}\n</code></pre>\n<p>发现编译后的结果一样证实.</p>\n<p>而默认情况下, <code>vue-loader</code> 是自动使用 <code>vue-style-loader</code> 的, 所以如果你不在 <code>.vue</code> 文件中 <code>@import</code> 任何 <code>css</code> , 那么你不需要手动把 <code>vue-loader-style</code> 放到 <code>vue.loaders</code> 字段中. <code>vue-loader</code> 会自动处理 <code>.vue</code> 文件中的 <code>style</code> 标签中的内容, 并将其放到 <code>style</code> 标签中插入页面. 而如果你需要在 <code>.vue</code> 文件中的 <code>style</code> 标签内 <code>@import css</code> 文件, 那么你就需要在 <code>module.exports.vue</code> 单独配置.可以通过把 <code>vue</code> 字段的 <code>vue-style-loader</code> 去掉来测试:</p>\n<pre><code class="hljs javascript"><span class="hljs-string">module:</span> {\n<span class="hljs-symbol">  loaders:</span>[\n    {\n<span class="hljs-symbol">      test:</span> <span class="hljs-regexp">/\\.vue$/</span>,\n<span class="hljs-symbol">      loader:</span> <span class="hljs-string">\'vue\'</span>\n    }\n  ]\n},\n<span class="hljs-string">vue:</span>{\n  <span class="hljs-comment">// loaders: {</span>\n  <span class="hljs-comment">//   css: \'vue-style-loader!css-loader\'</span>\n  <span class="hljs-comment">// }</span>\n}\n</code></pre>\n<p>此外, 入口文件 <code>js</code> 中的 <code>require(&#39;xxx.css&#39;)</code> 是默认的 <code>module.exports.module.loader</code> 处理的, 这点可以通过在默认 <code>loader</code> 中使用 <code>extract</code> 插件, 而在 <code>module.exports.vue</code> 中不使用 <code>extract</code> 插件证实, 因为从结果可以发现, 入口文件中的 <code>css</code> 被提取了, 但是 <code>.vue</code> 中的 <code>@import</code> 来的 <code>css</code> 没有被提取.</p>\n<p>而如果你需要 将入口文件中 <code>require</code> 来的 <code>css</code> 文件单独提取出来, 那么你就需要在 <code>module.exports.module.loader</code> 设置 <code>extract-text-webpack-plugin</code> 了. </p>\n<p>注意: <code>vue-style-loader</code> 放在 <code>module.exports.vue.loaders</code> 字段中是为了能提取出 <code>.vue</code> 文件中的 <code>style</code> 标签内容到一个单独的 <code>.css</code> 文件 <code>link</code> 在页面中, 把 <code>style-loader</code> 和 <code>css-loader</code> 放在默认的 <code>module.exports.module.loaders</code> 中, 对处理 <code>vue</code> 中的 <code>style</code> 标签内容无效------------起码在 <code>Vue 1.x</code> 版本和 <code>webpack 1.x</code> 版本无效, <code>webpack 2.x</code> 版本移除了第三方的字段, 限制在 <code>module.export</code> 中随意添加字段.</p>\n<p>最后, <code>css-loader</code> 和 <code>style-loader</code> 总是写在一起的, 因为 <code>css-loader</code> 的作用是 <code>resolve css</code> 文件中的 <code>@import</code> 和 属性值 <code>url()</code> 中的依赖关系, 单独写其实是没什么用的. <code>style-loader</code> 才是处理 <code>css</code>, 并将其打包到 <code>js</code> 中, 最后以 <code>&lt;style&gt;</code> 标签的形式插入到 <code>head</code> (插入位置可配置)中的 <code>loader</code>.</p>\n<p>最后讲讲 <code>extract-text-webpack-plugin</code>, 其接受三个参数:</p>\n<p>第一个参数是可选参数, 传入一个 <code>loader</code>, 当 <code>css</code> 样式没有被抽取的时候可以使用该 <code>loader</code>.\n第二个参数则是用于编译解析的 <code>css</code> 文件 <code>loader</code>, 很明显这个是必须传入的, 就像上述例子的 <code>css-loader</code>.\n第三个参数是一些额外的备选项, 貌似目前只有传入 <code>publicPath</code>, 用于当前 <code>loader</code> 的路径.</p>\n<p>那什么时候需要传入第一个参数呢,那就得明白什么时候样式不会被抽取出来.\n了解过 <code>code splitting</code> 的同学便会知道,我们有些代码在加载页面的时候不会被使用时, 使用 <code>code splitting</code>, 可以实现将这部分不会使用的代码分离出去, 独立成一个单独的文件,实现按需加载.</p>\n<p>那么如果在这些分离出去的代码中如果有使用 <code>require</code> 引入样式文件, 那么使用 <code>ExtractTextPlugin</code> 这部分样式代码是不会被抽取出来的.\n这部分不会抽取出来的代码, 可以使用 <code>loader</code> 做一些处理, 这就是 <code>ExtractTextPlugin.extract</code> 第一个参数的作用.</p>\n<p>OK, 聊完了配置文件, 再说说这个项目是怎么工作的.</p>\n<p>一图胜千言, 上图, 首先是代码界面: </p>\n<p><img src="http://img.xheldon.com/img/vue-test.png" alt="项目结构" title="项目结构"></p>\n<p>(若图片显示较小请在右键在新标签页单独查看)</p>\n<p>看箭头所示就明白啦, 首先一个页面是至少有一个组件的, 这个我直接就一个页面一个组件来写了, 没有 <code>import</code> 其他的组件.</p>\n<p>因此, 一个页面下是至少三个文件的, <code>.vue</code> 文件, <code>.js</code> 入口文件, 和 <code>.html</code>, 组件插入的文件.</p>\n<p><code>html</code> 中写一个组件 <code>app</code> 的名字, 入口文件实例化一个 <code>vue</code>, 然后使用 <code>app</code> 这个组件, 同时这个叫做 <code>app</code> 组件的模板来自 <code>index.vue</code>, 组件对应的 <code>css</code> 和 <code>js</code> 以及 <code>mvvm</code> 的特色:数据绑定也写在 <code>index.vue</code> 里面.</p>\n<p>有同学会疑惑, 入口文件 <code>js</code> 是怎么找到同目录的 <code>html</code> 文件的呢? 其实这个在 <code>webpack.config.js</code> 配置文件就已经写好了: </p>\n<pre><code class="hljs javascript"><span class="hljs-attribute">plugins</span>:[\n  new HtmlwebpackPlugin({\n    <span class="hljs-attribute">title</span>: <span class="hljs-string">\'Vue component test\'</span>,\n    <span class="hljs-attribute">filename</span>: <span class="hljs-string">\'this_is_final_filename_address_you_visit_in_browser.html\'</span>,<span class="hljs-comment">//生成的最终文件名</span>\n    <span class="hljs-attribute">template</span>: <span class="hljs-string">\'app/this_is_main_page_which_you_put_components_into.html\'</span>,<span class="hljs-comment">//放置组件的地方, 一般是一个 body 下一个孤零零的 app 标签即可.</span>\n    <span class="hljs-attribute">inject</span>: true\n  })\n]\n</code></pre>\n<p>这个 <code>html</code> 生成的插件告诉 <code>js</code> 入口文件, 所需要的模板来自 <code>app</code> 下的 <code>xxx.html</code>, 而最后打包的 <code>bundle.js</code> 也是 <code>inject</code> 这个里面, 再生成最终的页面.</p>\n<p>还有同学会问, 在入口 <code>js</code> 文件中, <code>vue</code> 实例化的时候用到的 <code>components.App</code> 到底是在编译过程就找到了 <code>this_is_main_page_which_you_put_components_into.html</code> 文件中的 <code>&lt;app&gt;</code> 组件引用, 还是在 <code>runtime</code> 的时候, 从最终打包的 <code>bundle.js</code> 中运行, 然后寻找 <code>this_is_final_filename_address_you_visit_in_browser.html</code> 页面中的 <code>&lt;app&gt;</code> 标签呢? 答案是后者, 因为刚才说的 <code>HtmlwebpackPlugin</code> 插件只负责生成 <code>html</code> 和注入打包后的 <code>bundle.js</code>, 而 <code>vue</code> 被打包进了 <code>bundle.js</code> 之后实例化 <code>vue</code> 时候才会寻找 <code>&lt;app&gt;</code> 标签.</p>\n<p>这么一看, 和直接在 <code>script</code> 标签中引用 <code>vue.js</code> 文件再渲染的效果是一样的, 只是 <code>webpack</code> 这种开发方式帮我们分离了组件, 使开发过程的代码/组件结构更清晰, 而且直接引用 <code>vue.js</code> 是前端 <code>runtime render</code>, 一个是 <code>compiler render</code> 之后直接执行, 后者效率更高.</p>\n<p>之后是效果页面:</p>\n<p><img src="http://img.xheldon.com/img/page-detail.png" alt="页面效果图" title="页面效果图">\n(若图片显示较小请在右键在新标签页单独查看)</p>\n<p>看图就明白什么意思啦.</p>\n<p>还有不明白的请看文档.</p>\n<p>暂时聊这么多, 关于 <code>vue</code> 和 <code>webpack</code> 的 <code>注意事项/细节/设计思想</code> 还有很多要说的, 回聊~</p>\n'},298:function(s,e){s.exports='<h1 id="webpack-">Webpack 异步按需加载</h1>\n<p>date:   2016-05-02 22:13:35 +0800</p>\n<h3 id="-webpack-framework-">分类: [Webpack,Framework]</h3>\n<hr>\n<p>webpack 想要实现异步加载, 即先加载主要模块, 用到某个模块或者多个模块(也即打包后的 chunk )的时候再发送请求加载.</p>\n<p>这样做的目的当然是加快页面的初次加载速度, 但不可避免的会发送额外的请求, 这两个本身就是个鱼与熊掌不可兼得的事情, 这里说一下异步加载的细节.</p>\n<p>实现主要是靠 <code>require.ensure([], callback)</code> 这个东西, 老实说我会注意到这个东西是因为在 <code>webpack.config.js</code> 的 <code>output</code> 字段有一个字段叫做 <code>chunkFilename</code>, 我这个打破沙锅的毛病就不得不想看看这个和 <code>filename</code> 字段有什么区别, 搜索了一下发现 <code>filename</code> (假设是 <code>bundle.js</code>) 是把页面需要的所有 <code>js</code> 打包, 最终生成的总的 <code>js</code> (当然多页面的时候可以提取公共模块, 这个不是本次的重点). 而 <code>chunkFilename</code> 是那些非入口点(<code>entry</code> 中列举的字段)的 <code>chunk</code> 文件打包生成的文件, 主要使用在按需异步加载模块的时候.</p>\n<p>这些文件没有打包在 <code>bundle.js</code> 中, 而且只被部分(非全部的)模块依赖, 同时又需要异步加载, 因此就会通过使用 <code>require.ensure</code> 被打包到额外的 <code>js</code> 中, 而这些 <code>js</code>, 仍然是通过最终的 <code>bundle.js</code> 创建 <code>script</code> 标签, 然后被 <code>append</code> 到页面中的:</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// This file contains only the entry chunk.</span>\n<span class="hljs-comment">// The chunk loading function for additional chunks</span>\n__webpack_require__.e = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requireEnsure</span>(<span class="hljs-params">chunkId, callback</span>) </span>{\n    <span class="hljs-comment">// "0" is the signal for "already loaded"</span>\n    <span class="hljs-keyword">if</span>(installedChunks[chunkId] === <span class="hljs-number">0</span>)\n        <span class="hljs-keyword">return</span> callback.call(<span class="hljs-literal">null</span>, __webpack_require__);\n\n    <span class="hljs-comment">// an array means "currently loading".</span>\n    <span class="hljs-keyword">if</span>(installedChunks[chunkId] !== <span class="hljs-literal">undefined</span>) {\n        installedChunks[chunkId].push(callback);\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// start chunk loading</span>\n        installedChunks[chunkId] = [callback];\n        <span class="hljs-keyword">var</span> head = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">\'head\'</span>)[<span class="hljs-number">0</span>];\n        <span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">\'script\'</span>);\n        script.type = <span class="hljs-string">\'text/javascript\'</span>;\n        script.charset = <span class="hljs-string">\'utf-8\'</span>;\n        script.async = <span class="hljs-literal">true</span>;\n\n        script.src = __webpack_require__.p + <span class="hljs-string">""</span> + ({}[chunkId]||chunkId) + <span class="hljs-string">".js"</span>;\n        head.appendChild(script);\n    }\n};\n</code></pre>\n<p>OK, 这些理解起来都很容易, 但是查看<a href="http://webpack.github.io/docs/code-splitting.html#defining-a-split-point" target="_blank">官方文档</a>的时候, 发现了几个需要注意的细节.</p>\n<h2 id="commonjs-amd-require-"><em><code>CommonJS</code></em> 和 <em><code>AMD</code></em> <code>require</code> 时候的区别</h2>\n<p><code>CommonJS</code> 是使用 <code>require.ensure([&#39;&#39;], callback)</code> 来处理异步加载模块的, <code>AMD</code> 是和一般的 <code>AMD</code> 模块一样, 使用 <code>require</code> 一个数组依赖的形式处理的 <code>require([&#39;&#39;], callback)</code></p>\n<p>但是 <code>CommonJS</code> 加载数组中模块的时候, 是只加载不执行, 除非是在 <code>callback</code> 中, 又 <code>require</code> 了一遍才执行: </p>\n<pre><code class="hljs javascript"><span class="hljs-built_in">require</span>([<span class="hljs-string">\'./other/ensure.js\'</span>,<span class="hljs-string">\'./other/ensure2.js\'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-keyword">var</span> ensure = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./other/ensure.js\'</span>);\n    <span class="hljs-keyword">var</span> ensure2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./other/ensure2.js\'</span>);\n\n    module1();\n    module2();\n}, chunkFilename);\n</code></pre>\n<blockquote>\n<p>The require.ensure method ensures that every dependency in dependencies can be synchronously required when calling the callback. An implementation of the require function is sent as a parameter to the callback.</p>\n</blockquote>\n<p>而且这个 <code>callback</code> 的参数, 是一个实现了 <code>require</code> 接口的函数(没错的话应该只是一个 <code>require</code> 函数的引用);</p>\n<p>这个 <code>chunkFilename</code> 会被 <code>output</code> 中的 <code>chunkFilename</code> 设置覆盖.</p>\n<p>而 <code>AMD</code> 因为是正常一贯的依赖前置, 所以其会在 <code>require</code> 的时候就执行模块: </p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">require</span>([<span class="hljs-string">\'./other/ensure.js\'</span>,<span class="hljs-string">\'./other/ensure2.js\'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-keyword">ensure</span>, ensure2)</span><span class="hljs-comment">{\n    ensure();\n    ensure2();\n}</span>);</span>\n</code></pre>\n<p>OK, <code>AMD</code> 的例子不熟, 下面以 <code>CommonJS</code> 为例说明一些细节.</p>\n<p>首先, 如果给 <code>require.ensure</code> 传递一个 <code>callback</code> , 则在回调函数中 <code>require</code> 来的模块也会被全部打包到最终异步加载的文件中.</p>\n<h2 id="chunk-"><code>chunk</code> 打包优化策略</h2>\n<ol>\n<li>如果两个 <code>chunk</code> 包含相同的模块, 那么他们将合并成一个.</li>\n<li>如果一个模块在一个 <code>chunk</code> 的所有父级 <code>chunk</code> 都可用, 那么该模块将会在该 <code>chunk</code> 中被移除.</li>\n<li>如果一个 <code>chunk</code> 包含了另一个 <code>chunk</code> 的所有模块, 那么最终将打包包含更多 <code>module</code> 的这个 <code>chunk</code>, 这个规则对一个 <code>chunk</code> 包含其他 多个 <code>chunk</code> 的所有 <code>module</code> 同样适用.</li>\n</ol>\n<p>其中第二条不好理解, 其实它所说的情况是, 在一个入口文件 <code>A.js</code> 中包含 <code>b</code> 模块, 而使用 <code>require.ensure</code> 打包生成了一个 <code>chunk.js</code> 文件中也包含这个 <code>b</code> 模块, 因为 <code>require.ensure</code> 是在 <code>A.js</code> 文件中调用的, 因此 <code>A.js</code> 算是这个 <code>chunk.js</code> 的父级 <code>chunk</code>, 那么最终打包生成的 <code>chunk.js</code> 中包含的 <code>b</code> 模块 内容将被移除. 而 <code>在所有父级 chunk 都可用</code> 指的是第一条所说的情况: 几个 <code>chunk</code> 包含相同的 <code>module</code>, 那么只会生成一个最终的 <code>bundle.js</code>, 但导致的可能是这个 <code>chunk</code> 存在多个父级 <code>chunk</code> (即 <code>entry</code> 对应的 <code>chunk</code> 文件).</p>\n<p>验证一下: </p>\n<p>入口文件 <code>app.js</code> 的代码:</p>\n<pre><code class="hljs javascript">\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'../other/if_be_remove.js\'</span>)();\n<span class="hljs-built_in">require</span>.ensure([<span class="hljs-string">\'../other/ensure.js\'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../other/ensure.js\'</span>)();\n}, <span class="hljs-string">\'love\'</span>);\n\n</code></pre>\n<p>另一个入口文件 <code>app2.js</code> 的代码:</p>\n<pre><code class="hljs javascript">\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'../other/if_be_remove.js\'</span>)();\n<span class="hljs-built_in">require</span>.ensure([<span class="hljs-string">\'../other/ensure2.js\'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../other/ensure2.js\'</span>)();\n}, <span class="hljs-string">\'hate\'</span>);\n\n</code></pre>\n<p><code>ensure.js</code> 的代码:</p>\n<pre><code class="hljs javascript">\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./if_be_remove.js\'</span>)();\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'i\\\'m be ensure!\'</span>);    \n}\n\n</code></pre>\n<p><code>ensure2.js</code> 的代码:</p>\n<pre><code class="hljs javascript">\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./if_be_remove.js\'</span>)();\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'i\\\'m be ensure2!\'</span>);    \n}\n\n</code></pre>\n<p>最后, 在子 <code>chunk</code> 和父级 <code>chunk</code> 都存在的 <code>if_be_remove.js</code> 的代码:</p>\n<pre><code class="hljs javascript">\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'im be removed!\'</span>);    \n}\n\n</code></pre>\n<p>看下 <code>Chrome</code> 浏览器控制台中 <code>Network</code> 中加载的 <code>js</code> 的内容(这里使用 <code>[id].[name].js</code> 的命名方式)</p>\n<p><code>app.js</code> 页面:</p>\n<p><img src="http://img.xheldon.com/img/webpack-async-1.png" alt="webpack-async" title="webpack-async"></p>\n<p><code>app2.js</code> 页面</p>\n<p><img src="http://img.xheldon.com/img/webpack-async-1.png" alt="webpack-async" title="webpack-async"></p>\n<p>可以看到, 因为 <code>if_be_remove.js</code> 在两个 <code>chunk</code> 中, 即 <code>1-love.js</code> 和 <code>3.hate.js</code> 被引用, 而同时又被这两个 <code>chunk</code> 的父级, 也即 <code>app.js</code> 和 <code>app2.js</code> 引用, 因此在这两个 <code>chunk</code> 中, 没有出现 <code>if_be_remove.js</code> 的代码.</p>\n<h2 id="-chunk-">补充: <code>chunk</code> 概念和定义</h2>\n<p>这里再补充一下, 所谓 <code>chunk</code>, 指的是一个或者几个 <code>module</code> 组成的一个独立的 <code>js</code> 文件, 而 <code>chunk</code> 分为以下几个类型:</p>\n<ol>\n<li><code>Entry Chunks</code>: <code>Entry Chunks</code>是我们最常见的<code>Chunks</code>类型, 包含了我们自己写的业务逻辑相关代码(大多数情况下是独有的代码, 即不会被提取到公共 <code>chunks</code> 中的代码), 一般会等到 <code>Initial Chunks</code> 加载完成才会执行(或者是遇到 <code>module</code> 编号为 <code>0</code> 的 module).</li>\n<li><code>Normal Chunks</code>: <code>Normal Chunks</code> 主要指代那些应用运行时动态加载的模块,<code>Webpack</code>会为我们创建类似于 <code>JSONP</code> 这样合适的加载器来进行动态加载.</li>\n<li><code>Initial Chunks</code>: <code>Initial Chunks</code> 本质上还是 <code>Normal Chunks</code>, 不过其会在应用初始化时完成加载, 往往这个类型的<code>Chunks</code>由<code>CommonsChunkPlugin</code>生成, 这个这个里面包含了全局的模块位置信息, <code>Entry chunks</code> 中的代码执行依赖这个 <code>chunk</code>, 因此应该优先加载这个 <code>js</code>.</li>\n</ol>\n<p>在之前的举例中, 被打包成公共 <code>js</code> 供全部或者部分页面使用的的 <code>bundule.js</code> 是 <code>Initial Chunks</code>, 只在当前页面才会用到的<code>chunk</code> 如 <code>app.xxxxxx.js</code> 是 <code>Entry Chunks</code>, 通过 <code>require.ensure</code> 异步加载的 <code>chunk</code> 如 <code>3-hate</code> <code>1-love</code> 是 <code>Normal Chunks</code>.</p>\n'},299:function(s,e){s.exports='<h1 id="-">博客域名优化配置说明</h1>\n<p>date:   2016-05-23 22:13:35 +0800</p>\n<h3 id="-others-">分类: [Others]</h3>\n<hr>\n<p>决定在 <code>GitHub Pages</code> 搞个静态博客的时候, 我就想要尽可能的加快打开速度, 因此使用了一些雕虫小技来加快打开速度, 提高用户体验.</p>\n<h2 id="-">优化</h2>\n<h2 id="-cdn-">使用百度 CDN 服务和七牛静态资源托管</h2>\n<p>本博客使用了 <code>Bootstrap/jQuery/fontawsome</code> 这三个库/字体文件, 因为 <code>Bootstrap</code> 我根据实际情况, 自己修改了些许内容以更加配合排版, 因此没有使用第三方的 <code>CDN</code>, 而是放在了七牛的资源服务器上, <code>jQuery</code> 使用的则是百度的静态公共资源服务.</p>\n<p>这里打个广告吧, 对于个人用户而言, 七牛在使用支付宝实名认证之后, 有 10G 的免费存储空间, 从实际效果看, 速度还是可以的, 我把域名 <code>img.xheldon.com CNAME</code> 到了七牛的资源服务器, 以供一些静态资源如上述的定制版 <code>Bootstrap</code> 和图片, 因此使用的时候只需要上传文件写好路径即可, 然后使用 <code>img.xheldon.com/path/filename.ext</code> 即可:</p>\n<p><img src="http://img.xheldon.com/img/qiniu.png" alt="七牛服务" title="七牛服务"></p>\n<p>说实话, 因为是静态博客, 所以请求带的 <code>Cookie</code> 不是很大, 因此将资源放到另一个二级域名的优化的作用不是很大, 不过聊胜于无.</p>\n<h2 id="-">将小资源直接放到页面中</h2>\n<p>我将一些小的 <code>css</code> 和 <code>js</code> 直接放到页面中, 如 <code>highlight.css</code> 和 <code>search.js</code>, 都通过 <code>style</code> 和 <code>script</code> 标签直接写到了页面中, 这样做的好处是很大的, 因为这两个文件小, 下载文件所需要的时间可以忽略不计, 如果使用外部引入的形式, 那么加载这两个文件的时间主要消耗在了 <a href="https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing" target="_blank"><code>TTFB</code></a> (需FQ)上了: </p>\n<p><img src="http://img.xheldon.com/img/TTFB.png" alt="TTFB" title="TTFB"></p>\n<h2 id="-">设置</h2>\n<p>因为年轻的时候没有见过世面, 于是直接将本站的 <code>A</code> 记录的 <code>www</code> 指向了 <code>Github Pages</code> 的 <code>IP 192.30.252.154/192.30.252.153</code>, 而把顶级域名 <code>@</code> 错误的使用 <code>CNAME</code> 指向了 <code>xheldon.github.io.</code>, 其实如果你没有 <code>MX</code> 指向 <code>@</code> 的话, 这样做是 <code>OK</code> 的, 但是因为我想在写简历的时候搞的酷一点, 使用自己博客的域名作为邮箱, 然后使用了 <code>QQ</code> 邮箱提供的域名邮箱服务, 因此在做 <code>MX</code> 解析的时候, 需要将顶级域名 <code>@</code>\n指向腾讯的 <code>mxdomain.qq.com</code>, 这个时候就报错了, 阿里云提示说 <code>CNAME</code> 和 <code>MX</code> 不能都指向顶级域名 <code>@</code>, 具体原因可以<a href="https://www.zhihu.com/question/21128056" target="_blank">看这里</a>, 但是到现在博客已经迁移几个月了, 一些链接也已经被搜索引擎抓取过了, 现在再修改的话链接的话损失有点大. </p>\n<p>我最开始的配置是这样的:</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">记录类型</th>\n<th style="text-align:center">主机记录</th>\n<th style="text-align:center">记录值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">CNAME</td>\n<td style="text-align:center">@</td>\n<td style="text-align:center">xheldon.github.io.</td>\n</tr>\n<tr>\n<td style="text-align:center">A</td>\n<td style="text-align:center">www</td>\n<td style="text-align:center">192.30.252.154</td>\n</tr>\n<tr>\n<td style="text-align:center">A</td>\n<td style="text-align:center">www</td>\n<td style="text-align:center">192.30.252.153</td>\n</tr>\n</tbody>\n</table>\n<p>因为使用腾讯域名邮箱, 所以需要做 <code>MX</code> 记录到 <code>@</code>, 而 <code>MX</code> 的 <code>@</code> 不能和 <code>CNAME</code> 的 <code>@</code> 共存, 于是我想到了隐形 <code>URL</code> 转发, 取消了 <code>CNAME</code> 指向 <code>@</code>, 增加了 <code>MX</code> 记录指向 <code>@</code> ,然后新增了隐性 <code>URL</code>:</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">记录类型</th>\n<th style="text-align:center">主机记录</th>\n<th style="text-align:center">记录值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">A</td>\n<td style="text-align:center">www</td>\n<td style="text-align:center">192.30.252.154</td>\n</tr>\n<tr>\n<td style="text-align:center">A</td>\n<td style="text-align:center">www</td>\n<td style="text-align:center">192.30.252.153</td>\n</tr>\n<tr>\n<td style="text-align:center">MX</td>\n<td style="text-align:center">@</td>\n<td style="text-align:center">mxdomain.qq.com.</td>\n</tr>\n<tr>\n<td style="text-align:center">CNAME</td>\n<td style="text-align:center">qqmailhash</td>\n<td style="text-align:center">mail.qq.com.</td>\n</tr>\n<tr>\n<td style="text-align:center">隐形URL</td>\n<td style="text-align:center">@</td>\n<td style="text-align:center"><a href="http://www.xheldon.com">www.xheldon.com</a></td>\n</tr>\n</tbody>\n</table>\n<p>同时将博客分支目录的 <code>CNAME</code> 文件从 <code>xheldon.com</code> 改成了 <code>www.xheldon.com</code> 然后发现从搜索引擎访问博客的话, 比如 <code>xheldon.com/about/</code>, 确实是跳转到了这个博客, 但是仅仅停留在首页! 也就是说, 之前被搜索引擎抓取的任何链接都只停留在首页 <code>www.xheldon.com</code> 这个地方, 这就意味着, 隐性转发的作用其实是对特定的地址做跳转, 并不会将地址后的路径自动加上去, 就比如我的情况, 隐形 <code>URL</code> 转发, 设置了从 <code>xheldon.com</code> 转发到 <code>www.xheldon.com</code> 之后, 所有的访问 <code>xheldon.com/xxxx</code> 的请求, 也都被转发到了 <code>www.xheldon.com</code>, 而不是期望的 <code>www.xheldon.com/xxxx</code>.</p>\n<p>此时 <code>dig xheldon.com</code>:</p>\n<pre><code class="hljs bash">; &lt;&lt;&gt;&gt; <span class="hljs-selector-tag">DiG</span> 9<span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.3-P1</span> &lt;&lt;&gt;&gt; <span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.com</span>\n;; <span class="hljs-selector-tag">global</span> <span class="hljs-selector-tag">options</span>: +<span class="hljs-selector-tag">cmd</span>\n;; <span class="hljs-selector-tag">Got</span> <span class="hljs-selector-tag">answer</span>:\n;; <span class="hljs-selector-tag">-</span>&gt;&gt;<span class="hljs-selector-tag">HEADER</span>&lt;&lt;<span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">opcode</span>: <span class="hljs-selector-tag">QUERY</span>, <span class="hljs-selector-tag">status</span>: <span class="hljs-selector-tag">NOERROR</span>, <span class="hljs-selector-tag">id</span>: 20871\n;; <span class="hljs-selector-tag">flags</span>: <span class="hljs-selector-tag">qr</span> <span class="hljs-selector-tag">rd</span> <span class="hljs-selector-tag">ra</span>; <span class="hljs-selector-tag">QUERY</span>: 1, <span class="hljs-selector-tag">ANSWER</span>: 1, <span class="hljs-selector-tag">AUTHORITY</span>: 0, <span class="hljs-selector-tag">ADDITIONAL</span>: 0\n\n;; <span class="hljs-selector-tag">QUESTION</span> <span class="hljs-selector-tag">SECTION</span>:\n;<span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.com</span>.            <span class="hljs-selector-tag">IN</span>    <span class="hljs-selector-tag">A</span>\n\n;; <span class="hljs-selector-tag">ANSWER</span> <span class="hljs-selector-tag">SECTION</span>:\n<span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.com</span>.        585    <span class="hljs-selector-tag">IN</span>    <span class="hljs-selector-tag">A</span>    42<span class="hljs-selector-class">.156</span><span class="hljs-selector-class">.141</span><span class="hljs-selector-class">.13</span>\n\n;; <span class="hljs-selector-tag">Query</span> <span class="hljs-selector-tag">time</span>: 7 <span class="hljs-selector-tag">msec</span>\n;; <span class="hljs-selector-tag">SERVER</span>: 172<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.200</span><span class="hljs-selector-class">.110</span><span class="hljs-selector-id">#53</span>(172<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.200</span><span class="hljs-selector-class">.110</span>)\n;; <span class="hljs-selector-tag">WHEN</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Mar</span> 30 10<span class="hljs-selector-pseudo">:06</span><span class="hljs-selector-pseudo">:41</span> 2017\n;; <span class="hljs-selector-tag">MSG</span> <span class="hljs-selector-tag">SIZE</span>  <span class="hljs-selector-tag">rcvd</span>: 45\n</code></pre>\n<p>发现顶级域名指向的是阿里云的一个 <code>IP</code>.</p>\n<p>于是我想了下, 修改了一下 <code>A</code> 记录的 <code>@</code> , 将其直接指向 <code>GitHub Pages</code> 的 <code>IP</code> 地址, 而博客根目录的 <code>CNAME</code> 文件内容是修改后的 <code>www.xheldon.com</code>:</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">记录类型</th>\n<th style="text-align:center">主机记录</th>\n<th style="text-align:center">记录值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">A</td>\n<td style="text-align:center">@</td>\n<td style="text-align:center">192.30.252.154</td>\n</tr>\n<tr>\n<td style="text-align:center">A</td>\n<td style="text-align:center">@</td>\n<td style="text-align:center">192.30.252.153</td>\n</tr>\n<tr>\n<td style="text-align:center">MX</td>\n<td style="text-align:center">@</td>\n<td style="text-align:center">mxdomain.qq.com</td>\n</tr>\n<tr>\n<td style="text-align:center">CNAME</td>\n<td style="text-align:center">qqmailhash</td>\n<td style="text-align:center">mail.qq.com.</td>\n</tr>\n<tr>\n<td style="text-align:center">CNAME</td>\n<td style="text-align:center">www</td>\n<td style="text-align:center">github.xheldon.com.</td>\n</tr>\n</tbody>\n</table>\n<p>之所以可以这么做, 是因为 <code>Github Pages</code> <a href="https://help.github.com/articles/setting-up-an-apex-domain-and-www-subdomain/" target="_blank">自动匹配</a>, 具体解释起来就是: </p>\n<ol>\n<li>如果 <code>CNAME</code> 文件内容是 <code>www.xheldon.com</code>, 而发现有来自 <code>xheldon.com</code> 的请求时候(需要配置顶级域名 <code>@</code> 的 <code>A</code> 记录指向 <code>GitHub Pages</code> 的 <code>IP</code> 实现), 就转发到 <code>www.xheldon.com</code>.</li>\n<li>如果 <code>CNAME</code> 文件内容是 <code>xheldon.com</code>, 而发现有来自 <code>www.xheldon.com</code> 的请求时候(需要配置 <code>www</code> 的二级域名 <code>A</code> 记录指向 <code>GitHub Pages</code> 的 <code>IP</code> 实现), 就转发到 <code>xheldon.com</code>.</li>\n</ol>\n<p>这个时候 <code>dig www.xheldon.com</code> 发现:</p>\n<pre><code class="hljs javascript">; &lt;&lt;&gt;&gt; <span class="hljs-selector-tag">DiG</span> 9<span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.3-P1</span> &lt;&lt;&gt;&gt; <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.xheldon</span><span class="hljs-selector-class">.com</span>\n;; <span class="hljs-selector-tag">global</span> <span class="hljs-selector-tag">options</span>: +<span class="hljs-selector-tag">cmd</span>\n;; <span class="hljs-selector-tag">Got</span> <span class="hljs-selector-tag">answer</span>:\n;; <span class="hljs-selector-tag">-</span>&gt;&gt;<span class="hljs-selector-tag">HEADER</span>&lt;&lt;<span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">opcode</span>: <span class="hljs-selector-tag">QUERY</span>, <span class="hljs-selector-tag">status</span>: <span class="hljs-selector-tag">NOERROR</span>, <span class="hljs-selector-tag">id</span>: 56061\n;; <span class="hljs-selector-tag">flags</span>: <span class="hljs-selector-tag">qr</span> <span class="hljs-selector-tag">rd</span> <span class="hljs-selector-tag">ra</span>; <span class="hljs-selector-tag">QUERY</span>: 1, <span class="hljs-selector-tag">ANSWER</span>: 3, <span class="hljs-selector-tag">AUTHORITY</span>: 0, <span class="hljs-selector-tag">ADDITIONAL</span>: 0\n\n;; <span class="hljs-selector-tag">QUESTION</span> <span class="hljs-selector-tag">SECTION</span>:\n;<span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.xheldon</span><span class="hljs-selector-class">.com</span>.        <span class="hljs-selector-tag">IN</span>    <span class="hljs-selector-tag">A</span>\n\n;; <span class="hljs-selector-tag">ANSWER</span> <span class="hljs-selector-tag">SECTION</span>:\n<span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.xheldon</span><span class="hljs-selector-class">.com</span>.    600    <span class="hljs-selector-tag">IN</span>    <span class="hljs-selector-tag">CNAME</span>    <span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span>.\n<span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span>.    3600    <span class="hljs-selector-tag">IN</span>    <span class="hljs-selector-tag">CNAME</span>    <span class="hljs-selector-tag">github</span><span class="hljs-selector-class">.map</span><span class="hljs-selector-class">.fastly</span><span class="hljs-selector-class">.net</span>.\n<span class="hljs-selector-tag">github</span><span class="hljs-selector-class">.map</span><span class="hljs-selector-class">.fastly</span><span class="hljs-selector-class">.net</span>.  28  <span class="hljs-selector-tag">IN</span>      <span class="hljs-selector-tag">A</span>      151<span class="hljs-selector-class">.101</span><span class="hljs-selector-class">.100</span><span class="hljs-selector-class">.133</span>\n\n;; <span class="hljs-selector-tag">Query</span> <span class="hljs-selector-tag">time</span>: 178 <span class="hljs-selector-tag">msec</span>\n;; <span class="hljs-selector-tag">SERVER</span>: 172<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.200</span><span class="hljs-selector-class">.110</span><span class="hljs-selector-id">#53</span>(172<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.200</span><span class="hljs-selector-class">.110</span>)\n;; <span class="hljs-selector-tag">WHEN</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Mar</span> 30 10<span class="hljs-selector-pseudo">:20</span><span class="hljs-selector-pseudo">:30</span> 2017\n;; <span class="hljs-selector-tag">MSG</span> <span class="hljs-selector-tag">SIZE</span>  <span class="hljs-selector-tag">rcvd</span>: 115\n</code></pre>\n<p><code>dig xheldon.com</code> 发现: </p>\n<pre><code class="hljs javascript">; &lt;&lt;&gt;&gt; <span class="hljs-selector-tag">DiG</span> 9<span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.3-P1</span> &lt;&lt;&gt;&gt; <span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.com</span>\n;; <span class="hljs-selector-tag">global</span> <span class="hljs-selector-tag">options</span>: +<span class="hljs-selector-tag">cmd</span>\n;; <span class="hljs-selector-tag">Got</span> <span class="hljs-selector-tag">answer</span>:\n;; <span class="hljs-selector-tag">-</span>&gt;&gt;<span class="hljs-selector-tag">HEADER</span>&lt;&lt;<span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">opcode</span>: <span class="hljs-selector-tag">QUERY</span>, <span class="hljs-selector-tag">status</span>: <span class="hljs-selector-tag">NOERROR</span>, <span class="hljs-selector-tag">id</span>: 59875\n;; <span class="hljs-selector-tag">flags</span>: <span class="hljs-selector-tag">qr</span> <span class="hljs-selector-tag">rd</span> <span class="hljs-selector-tag">ra</span>; <span class="hljs-selector-tag">QUERY</span>: 1, <span class="hljs-selector-tag">ANSWER</span>: 2, <span class="hljs-selector-tag">AUTHORITY</span>: 0, <span class="hljs-selector-tag">ADDITIONAL</span>: 0\n\n;; <span class="hljs-selector-tag">QUESTION</span> <span class="hljs-selector-tag">SECTION</span>:\n;<span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.com</span>.            <span class="hljs-selector-tag">IN</span>    <span class="hljs-selector-tag">A</span>\n\n;; <span class="hljs-selector-tag">ANSWER</span> <span class="hljs-selector-tag">SECTION</span>:\n<span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.com</span>.        600    <span class="hljs-selector-tag">IN</span>    <span class="hljs-selector-tag">A</span>    192<span class="hljs-selector-class">.30</span><span class="hljs-selector-class">.252</span><span class="hljs-selector-class">.154</span>\n<span class="hljs-selector-tag">xheldon</span><span class="hljs-selector-class">.com</span>.        600    <span class="hljs-selector-tag">IN</span>    <span class="hljs-selector-tag">A</span>    192<span class="hljs-selector-class">.30</span><span class="hljs-selector-class">.252</span><span class="hljs-selector-class">.153</span>\n\n;; <span class="hljs-selector-tag">Query</span> <span class="hljs-selector-tag">time</span>: 462 <span class="hljs-selector-tag">msec</span>\n;; <span class="hljs-selector-tag">SERVER</span>: 172<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.200</span><span class="hljs-selector-class">.110</span><span class="hljs-selector-id">#53</span>(172<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.200</span><span class="hljs-selector-class">.110</span>)\n;; <span class="hljs-selector-tag">WHEN</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Mar</span> 30 12<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:23</span> 2017\n;; <span class="hljs-selector-tag">MSG</span> <span class="hljs-selector-tag">SIZE</span>  <span class="hljs-selector-tag">rcvd</span>: 61\n</code></pre>\n'},300:function(s,e){s.exports='<h1 id="vue-">Vue 学习总结</h1>\n<p>date:   2016-06-01 22:13:35 +0800</p>\n<h3 id="-vue-framework-">分类: [Vue, Framework]</h3>\n<hr>\n<p>这篇文章从<a herf="https://cn.vuejs.org/v2/guide/instance.html" target="_blank"><code>Vue 2.0官方文档</code></a>的&quot;实例&quot;一节开始, 研究一些 <code>Vue API</code> 的使用方法, 以及 <code>Vue</code> 实现一些功能的原理, 此外还有自己的使用感受, 以及站在自己浅薄的角度分析 <code>Vue</code> 为什么要这么设计的不敬之举, 如有得罪还请海涵, 刚接触 <code>Vue</code> 不久, 不当之处烦请指出, 先行谢过.</p>\n<blockquote>\n<p>注意: 基础知识直接略过, 我只说我认为需要说的点.</p>\n</blockquote>\n<h2 id="vue-">Vue 实例</h2>\n<p>每个 <code>Vue.js</code> 的应用都是通过构造函数创建一个 <code>Vue</code> 的根实例启动的, 意思就是, 每个页面的数据都应该只由这一个实例维护, 原始数据的来源都应该只由根实例来发出和接收统一管理, 根实例再通过 <code>props</code>, 分发数据, 或者 <code>events</code> 来监听数据. 子组件只需要 <code>watch/computed</code> 数据变化, 及时更新即可.</p>\n<p>文档中说了一句话叫: <code>所有的 Vue.js 组件其实都是被扩展的 Vue 实例</code>, 这句话正确理解起来应该是, 你可以在组件上使用和实例一样的方法和钩子函数, 除了 <code>data</code> .</p>\n<p>组件中的 <code>data</code>, 必须是一个函数, 因为组件会被复用, 所以必须每次调用组件都生成一份数据. </p>\n<p>数据代理(proxy), 指的是 <code>Vue</code> 实例会代理其 <code>data</code> 对象中的所有属性, 而实例属性 <code>$data</code> 则表示 <code>data</code> 属性本身, 以区别被代理的 <code>data</code>.</p>\n<p>意思是, 如果一个 <code>vm</code> 的 <code>data</code> 属性为 <code>{a: &#39;xheldon&#39;}</code>, 那么 <code>vm.a</code> 即为 <code>&#39;xheldon&#39;</code>, 而 <code>vm.$data</code> 则为 <code>{a: &#39;xheldon&#39;}</code>.</p>\n<p>组件其实也是一个(被扩展的) <code>Vue</code> 实例, 下面是个简单的验证:</p>\n<p>有一个 <code>list.vue</code> 组件(<code>template</code> 和 <code>style</code> 省略):</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">\'vue\'</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{\n  data(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Vue);<span class="hljs-regexp">//</span><span class="hljs-literal">true</span>\n    <span class="hljs-keyword">return</span> {}\n  }\n  name: <span class="hljs-string">\'com-list\'</span>\n}\n</code></pre>\n<h2 id="props-vs-data">props vs data</h2>\n<p>初始化组件的时候, <code>prop</code> 上的属性和 <code>data</code> 上的属性以及 <code>computed</code> 的方法, 都被绑定到 <code>Vue</code> 实例上了, 但是 <code>porps</code> 上的属性, 优先级比 <code>data</code> 同名属性要高,下面是验证:</p>\n<pre><code class="hljs javascript">export <span class="hljs-keyword">default</span>{\n  <span class="hljs-keyword">data</span>(){\n    console.log(<span class="hljs-string">\'first:\'</span>,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//list 的实例</span>\n    <span class="hljs-keyword">return</span> {\n      a: <span class="hljs-string">\'a\'</span>,<span class="hljs-comment">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>\n      d: <span class="hljs-string">\'d\'</span>\n    }\n  },\n  props: [<span class="hljs-string">\'a\'</span>],<span class="hljs-comment">//和 data 中的 a 属性同名, 因此来自父级的数据将 data 中的同名属性 a 上的数据覆盖.(注:父级是根组件, 挂载在一个实例上)</span>\n  name: <span class="hljs-string">\'com-list\'</span>\n}\n</code></pre>\n<p>结果出现警告(不是报错, 不影响渲染):</p>\n<pre><code class="hljs javascript">[Vue warn]: The data property <span class="hljs-string">"a"</span> is already declared as a prop. Use prop<span class="hljs-built_in"> default </span>value instead.\n</code></pre>\n<p><img src="http://img.xheldon.com/img/propsVSdata.png" alt="props VS data" title="props VS data"></p>\n<p>而 <code>computed</code> 返回的函数名和 <code>data</code> 上的属性名可以重复, 并且不会有任何提示, 但是同名覆盖了之后, 因为在初始化的时候, 从控制台可以看到 <code>_data</code> 后于 <code>_computedWatcher</code> 来设置这个重复属性的 <code>getter</code> 和 <code>setter</code>(不知道是不是这个原因, 先放在这个地方以待我深入研究之后再修改这篇文章), 因此导致了被覆盖. 相关原理可以<a href="https://juejin.im/entry/577639de165abd00547b0924" target="_blank">看这篇介绍</a></p>\n<p>它们都在初始化的时候绑定到了实例 <code>属性</code> 上, 同名的 <code>computed</code> 属性被覆盖了, 但是 <code>Vue devtool</code> 仍然正确显示了出来)</p>\n<pre><code class="hljs javascript">export <span class="hljs-keyword">default</span>{\n  <span class="hljs-keyword">data</span>(){\n    console.log(<span class="hljs-string">\'first:\'</span>,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//list 的实例</span>\n    <span class="hljs-keyword">return</span> {\n      ab: <span class="hljs-string">\'a\'</span>,<span class="hljs-comment">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>\n    }\n  },\n  computed: {\n    ab(){\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'computed a\'</span>;<span class="hljs-comment">//方法名跟 data 上的 a 属性同名, 因此console 出来的 this 不会出现它的值, 用花括号输出的时候也是输出的 data 上的同名属性</span>\n    },\n    f(){\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'computed f\'</span><span class="hljs-comment">//方法名没有重复的, 因此 console 出来的 this 会有它的同名属性, 且值为 \'computed f\', 我们提供的 function 被作为该属性的 getter(计算属性默认只有 getter, 可以手动添加 setter)</span>\n    }\n  },\n  name: <span class="hljs-string">\'com-list\'</span>\n}\n</code></pre>\n<p><img src="http://img.xheldon.com/img/computedVSdata1.png" alt="computed VS data" title="computed VS data"></p>\n<p><code>Vue devtool</code> 正确显示了出来:</p>\n<p><img src="http://img.xheldon.com/img/computedVSdata3.png" alt="computed VS data" title="computed VS data"></p>\n<p>如果 <code>computed</code> 上的方法名和 <code>data</code> 上的属性名不重复:</p>\n<pre><code class="hljs javascript">export <span class="hljs-keyword">default</span>{\n  <span class="hljs-keyword">data</span>(){\n    console.log(<span class="hljs-string">\'first:\'</span>,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//list 的实例</span>\n    <span class="hljs-keyword">return</span> {\n      a: <span class="hljs-string">\'a\'</span>,<span class="hljs-comment">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>\n    }\n  },\n  computed: {\n    ab(){\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'computed a\'</span>;<span class="hljs-comment">//方法名跟 data 上的 a 属性同名, 因此 console 出来的 this 不会出现它的值, 但 Vue devtool 控制台正确显示了出来, 用花括号输出的时候也是其返回值 computed a.</span>\n    },\n    f(){\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'computed f\'</span><span class="hljs-comment">//方法名没有重复的, 因此 console 出来的 this 会有它的同名属性, 且值为 \'computed f\', 我们提供的 function 被作为该属性的 getter</span>\n    }\n  },\n  name: <span class="hljs-string">\'com-list\'</span>\n}\n</code></pre>\n<p><img src="http://img.xheldon.com/img/computedVSdata2.png" alt="computed VS data" title="computed VS data"></p>\n<p>此外, <code>methods</code> 和 <code>computed</code> 方法的区别除了后者有缓存而前者没有外(即后者除非其所依赖的响应式数据发生变化, 否则不会重新计算), 如果两者均是为了返回插值的话,则 <code>methods</code> 上的方法使用是 <code>functionName()</code>,\n而 <code>computed</code> 上的方法引用是 <code>functionName</code>, 即前者需要执行函数, 后者不需要执行.</p>\n<p>究其原因, 是因为 <code>computed</code> 属性上的我们写的方法, 被当做一个属性, 挂载到 <code>Vue</code> 实例上了, 而我们提供的函数, 被当做此方法的 <code>getter</code>.</p>\n<p>而 <code>methods</code> 不同, 它就是一个函数, 因此无论是插值引用, 还是事件方法, 都需要使用()来调用.</p>\n<p>这样的话, 当需要真正的函数------这里如果使用函数调用, 则 <code>computed</code> 需要返回一个函数不仅仅指是返回一个值, 而是需要传递参数------的时候, <code>metohds</code> 首当其冲.</p>\n<p>下面是一个不同于官网的另一个版本的 <code>todo list</code>:</p>\n<p>模板:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>\n  @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">"addToList"</span>\n  <span class="hljs-attr">v-model</span>=<span class="hljs-string">"todotext"</span>\n  /&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n  </span><span class="hljs-template-tag">{% <span class="hljs-name">raw</span> %}</span><span class="xml">\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, key) in todolist"</span>&gt;</span>\n    </span><span class="hljs-template-variable">{{key}}</span><span class="xml">:</span><span class="hljs-template-variable">{{value}}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"deletetodo(key)"</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  </span><span class="hljs-template-tag">{% <span class="hljs-name">endraw</span> %}</span><span class="xml">\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript">export <span class="hljs-keyword">default</span>{\n  <span class="hljs-keyword">data</span>(){\n    <span class="hljs-keyword">return</span>{\n      todolist:[],\n      todotext:<span class="hljs-string">\'\'</span>\n    }\n  },\n  methods: {\n    addToList(){\n      <span class="hljs-keyword">this</span>.todolist.push(<span class="hljs-keyword">this</span>.todotext);\n    },\n    deletetodo(key){\n      console.log(arguments);\n      <span class="hljs-keyword">this</span>.todolist.splice(key, <span class="hljs-number">1</span>);\n    }\n  }<span class="hljs-comment">/*,\n  computed:{\n    deletetodo(key){//不接收参数\n      console.log(arguments);\n      this.todolist.splice(key, 1);\n    }\n  }*/</span>\n}\n</code></pre>\n<p>此例子中, 如果使用这种模板, 则需要传递一个参数, 以在点击 <code>button</code> 的时候删除当前 <code>li</code>, 因此这个情况必须使用 <code>methods</code>.</p>\n<p>使用 <code>computed</code> 的时候, 不接受参数<a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/" target="_blank">(因为是一个 <code>getter</code>)</a>, 即使其返回一个 <code>function</code> :</p>\n<pre><code class="hljs javascript">computed:{\n  deletetodo(key){\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//控制台输出当前组件实例</span>\n      <span class="hljs-keyword">this</span>.todolist.splice(key, <span class="hljs-number">1</span>);<span class="hljs-comment">//报错</span>\n    }\n  }\n}\n</code></pre>\n<p>注意: 若两者存在同名函数, 那么 <code>computed</code> 上的函数优先级比 <code>methods</code> 高(处理 <code>getter</code> 和 <code>setter</code> 先后顺序的问题, 具体可查看源码), 这个情况无论是对插值还是事件绑定都适用, 以下是验证:</p>\n<p>插值引用测试:</p>\n<p>模板:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">{{a()}}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n</code></pre>\n<pre><code class="hljs javascript">methods:{\n  a(){\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'im from methods\'</span>\n  }\n},\ncomputed:{\n  a(){\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'im from computed\'</span>\n    }\n  }\n}\n</code></pre>\n<p>输出函数 <code>im from computed</code>, 如果 <code>computed</code> 不返回函数, 插值引用只使用 <code>{{a}}</code> 则显而易见更是输出 <code>computed</code> 的值, 验证此处略.</p>\n<p>事件绑定的时候:</p>\n<p>调用的时候使用<a href="https://cn.vuejs.org/v2/guide/events.html#内联处理器方法" target="_blank">内联处理器方法</a>:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">div</span> @click=<span class="hljs-string">"a()"</span>&gt;click <span class="hljs-keyword">me</span>&lt;/<span class="hljs-keyword">div</span>&gt;\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript">methods:{\n  a(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'methods\'</span>)\n  }\n},\n<span class="hljs-attr">computed</span>:{\n  a(){\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-comment">//computed 返回一个函数</span>\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'computed\'</span>)\n    }\n  }\n}\n</code></pre>\n<p>输出 <code>computed</code></p>\n<p>如果使用<a href="https://cn.vuejs.org/v2/guide/events.html#方法事件处理器" target="_blank">方法事件处理器</a>, 结果一样:</p>\n<pre><code class="hljs html">&lt;div @<span class="hljs-built_in">click</span>=<span class="hljs-string">"a"</span>&gt;<span class="hljs-built_in">click</span> me&lt;/div&gt;<span class="hljs-comment">//注意此处不带括号</span>\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript">methods:{\n  a(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'methods\'</span>)\n  }\n},\n<span class="hljs-attr">computed</span>:{\n  a(){\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-comment">//computed 返回一个函数</span>\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'computed\'</span>)\n    }\n  }\n}\n</code></pre>\n<p>输出 <code>computed</code></p>\n<p>注意事件绑定的时候, <code>computed</code> 都需要返回一个函数.</p>\n<p>因此优先级的顺序是:</p>\n<p><code>porps &gt; data &gt; computed &gt; methods</code></p>\n<p>我猜测在 <code>computed</code> 和 <code>methods</code> 中的 <code>this.xxx</code> 中的引用优先级也是相同的, 想搞明白的可以去验证下.</p>\n<p>而且可以看到, 两种情况 <code>method</code> 都不用返回一个 <code>function</code> , 而两种情况 <code>computed</code> 都需要返回一个 <code>function</code> 而且都不接受参数(因为是 <code>getter</code>). 综上所述, 事件处理最好使用 <code>methods</code>, 而数据绑定/插值处理 最好使用 <code>computed</code>(因为有缓存).</p>\n<p>此外, 对于 <code>method</code> 绑定事件的时候, 带()和不带()的效果是一样的, 都会执行其函数, 区别有以下几个:</p>\n<ol>\n<li><code>带()的叫内联语句</code>, 分两种情况, 原生事件和自定义事件. 两种情况都可以传参, 如果参数列表为空, 则默认参数 <code>arguments</code> 也为空, 即不存在默认参数; 如果是被一个原生事件如 <code>input/click</code> 触发的, 则可以传递一个特殊的 <code>$event</code> 参数作为原生 <code>event</code> 事件处理; 而如果是被一个自定义事件触发的, 其事件处理函数的参数仍然取决于实际传递给事件处理函数的值, 而且自定义函数不存在特殊的 <code>$event</code> 对象供使用. 由 <code>$emit</code> 触发自定义事件时传递的参数将被忽略.</li>\n<li><code>不带()叫方法事件</code>, 则分两种情况: 如果是原生事件, 则会传递原生 <code>event</code> 事件作为唯一的默认参数; 如果是自定义事件, 则传递的是 <code>$emit</code> 事件的时候除了事件名外的第二到最后一个任意数量的参数.</li>\n</ol>\n<blockquote>\n<p>talk is cheap, show me the code</p>\n</blockquote>\n<p>上面说的是四个情况:</p>\n<p>1.带()的原生事件</p>\n<pre><code class="hljs javascript">&lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-meta">@click</span>=<span class="hljs-string">"test1()"</span>&gt;<span class="hljs-comment">//模板里面传参为空</span>\nmethods:{\n  test1(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//则逻辑中的参数也为空;</span>\n  }\n}\n</code></pre>\n<p>2.带()的自定义事件</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">//子模板</span>\n&lt;input type=<span class="hljs-string">"text"</span> @input=<span class="hljs-string">"shuru($event)"</span>/&gt;\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{xheldon}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n<span class="hljs-comment">//子逻辑:</span>\nname: <span class="hljs-string">\'child\'</span>,\n<span class="hljs-attr">props</span>:[<span class="hljs-string">\'xheldon\'</span>],\n<span class="hljs-attr">method</span>:{\n  shuru(e){\n    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'haha\'</span>, e.target.value,<span class="hljs-string">\'其他参数\'</span>);\n  }\n}\n<span class="hljs-comment">//父模板</span>\n&lt;child :xheldon=<span class="hljs-string">"blob"</span> @haha=<span class="hljs-string">"something()"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span>\n<span class="hljs-comment">//父逻辑:</span>\nmethods:{\n  something(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'parent:\'</span>,...arguments);<span class="hljs-comment">//上面 something() 中传 xxx, 则输出 \'parent:xxx\', 即忽略了子组件 $emit 事件时候传递的参数.</span>\n    <span class="hljs-keyword">this</span>.blob = <span class="hljs-built_in">arguments</span>;\n  }\n}\n</code></pre>\n<p>3.不带()的原生事件</p>\n<pre><code class="hljs javascript">&lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-meta">@click</span>=<span class="hljs-string">"test1"</span>&gt;\nmethods:{\n  test1(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//结果: 输出原生的 MouseEvent 事件</span>\n  }\n}\n</code></pre>\n<p>4.不带()的自定义事件</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">//子模板</span>\n&lt;input type=<span class="hljs-string">"text"</span> @input=<span class="hljs-string">"shuru($event)"</span>/&gt;\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{xheldon}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n<span class="hljs-comment">//子逻辑:</span>\nname: <span class="hljs-string">\'child\'</span>,\n<span class="hljs-attr">props</span>:[<span class="hljs-string">\'xheldon\'</span>],\n<span class="hljs-attr">method</span>:{\n  shuru(e){\n    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'haha\'</span>, e.target.value,<span class="hljs-string">\'其他参数\'</span>);\n  }\n}\n<span class="hljs-comment">//父模板</span>\n&lt;child :xheldon=<span class="hljs-string">"blob"</span> @haha=<span class="hljs-string">"something"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span>\n<span class="hljs-comment">//父逻辑:</span>\nmethods:{\n  something(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'parent:\'</span>,...arguments);<span class="hljs-comment">//input 输入 xxx, 则输出 \'parent: xxx 其他参数\', 即与子组件 $emit 时候传递的参数相关.</span>\n    <span class="hljs-keyword">this</span>.blob = <span class="hljs-built_in">arguments</span>;\n  }\n}\n</code></pre>\n<h2 id="-">指令和参数(属性)</h2>\n<p>基本用法:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">div</span> v-directive:propNamed.modifiers=<span class="hljs-string">"value"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;\n</code></pre>\n<p>其中, <code>directive</code> 叫做指令, <code>propName</code> 叫做指令的&quot;参数&quot;, 实际上参数的具体表现就是 <code>html</code> 上的属性(<code>Vue</code> 内置了一些参数/属性, 如 <code>v-bind:click=&quot;method&quot;</code>, 的 <code>click</code>, 如 <code>v-bind:href=&quot;/img/x.png&quot;</code> 的 <code>href</code>, 前者不会出现在行内, 而后者因为是必须的因此会出现在行内属性. 而自己定义的参数/属性, 一定会出现在行内属性). 而 <code>value</code> 是个变量(虽然它写在双引号中)大多数情况下来自于父级模板.</p>\n<p><code>propName</code> 可以带个修饰符, 用来快捷操作一些行为如禁止默认事件 <code>.prevent</code> 等.</p>\n<p>有些指令可以直接使用如 <code>v-if</code>, 有些必须加上参数: <code>v-bind:href/v-on:click</code></p>\n<p>注意, <code>value</code> 带不带双引号结果都是一样的, 即 <code>:propName=&quot;value&quot;</code> 和 <code>:propName=value</code> 是一样的, 除特殊说明, 下列所有情况均适用.</p>\n<p>如果 <code>value</code> 转换成布尔值后为 <code>false</code> 则 <code>propName</code> 被移除, 为 <code>true</code> 则该 <code>propName</code> 出现, 实际上, 它遵守以下规则(仅限自定义属性):</p>\n<p>1.<code>null</code>, <code>undefined</code>, <code>false</code> 的直接量, <code>propName</code> 属性被移除.\n2.<code>value</code> 为一个未定义的变量, 如 <code>:propName=&quot;wxd&quot;</code> 则 <code>propName</code> 移除, 且出现警告:</p>\n<pre><code class="hljs javascript">[Vue warn]: Property <span class="hljs-keyword">or</span> method <span class="hljs-string">"s"</span> is <span class="hljs-keyword">not</span> defined on the<span class="hljs-built_in"> instance </span>but referenced during render. Make sure <span class="hljs-keyword">to</span> declare reactive data properties <span class="hljs-keyword">in</span> the data option. \n</code></pre>\n<p>3.如果 <code>value</code> 为一个数组, 因为数组为对象, 因此 <code>propName</code> 除了下面第二种情况外, 恒存在, 而 <code>value</code> 分以下情况:</p>\n<ol>\n<li><p><code>:propName =[]</code>, <code>:propName =&quot;[]&quot;</code>, <code>:propName =&quot;[&#39;&#39;]&quot;</code> <code>value</code> 移除, 即只有属性没有值.</p>\n</li>\n<li><p><code>:propName =[&quot;&quot;]</code>, 结构乱掉.</p>\n</li>\n<li><p><code>:propName =[&quot;&quot;,&quot;&quot;]</code> 或者 <code>:propName =&#39;[&quot;&quot;,&quot;&quot;]&#39;</code>, <code>value</code> 值为<code>&quot;,&quot;</code></p>\n</li>\n<li><p>如果 <code>value</code> 为一个嵌套数组, 则其值被一维化后, 如果 <code>value</code> 包含及其递归子元素包含一个为 <code>undefined</code> 或者 <code>null</code> 直接量(不是写到字符串里面的), 则该处的值留空; 如果 <code>value</code> 包含及其递归子元素包含一个 <code>Object</code>, 则该处的值为 <code>[object Object]</code></p>\n</li>\n</ol>\n<p>4.如果 <code>value</code> 为一个对象, 则 <code>propName</code> 保留, 值为 <code>[object Object]</code></p>\n<p>5.如果 <code>value</code> 为一个数字或者字符串, 如 <code>:propName = &quot;&#39;fff&#39;&quot;</code>, 则 <code>propName</code> 保留, <code>value</code>为字符串或数字值.</p>\n<p>看了下源码, 也确实是这么个逻辑:</p>\n<pre><code class="hljs javascript">function setAttr (el, <span class="hljs-built_in">key</span>, value) {\n  <span class="hljs-keyword">if</span> (isBooleanAttr(<span class="hljs-built_in">key</span>)) {\n    <span class="hljs-comment">// set attribute for blank value</span>\n    <span class="hljs-comment">// e.g. &lt;option disabled&gt;Select one&lt;/option&gt;</span>\n    <span class="hljs-keyword">if</span> (isFalsyAttrValue(value)) {\n      el.removeAttribute(<span class="hljs-built_in">key</span>);\n    } <span class="hljs-keyword">else</span> {\n      el.setAttribute(<span class="hljs-built_in">key</span>, <span class="hljs-built_in">key</span>);\n    }\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isEnumeratedAttr(<span class="hljs-built_in">key</span>)) {\n    el.setAttribute(<span class="hljs-built_in">key</span>, isFalsyAttrValue(value) || value === <span class="hljs-string">\'false\'</span> ? <span class="hljs-string">\'false\'</span> : <span class="hljs-string">\'true\'</span>);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isXlink(<span class="hljs-built_in">key</span>)) {\n    <span class="hljs-keyword">if</span> (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(<span class="hljs-built_in">key</span>));\n    } <span class="hljs-keyword">else</span> {\n      el.setAttributeNS(xlinkNS, <span class="hljs-built_in">key</span>, value);\n    }\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">if</span> (isFalsyAttrValue(value)) {\n      el.removeAttribute(<span class="hljs-built_in">key</span>);\n    } <span class="hljs-keyword">else</span> {\n      el.setAttribute(<span class="hljs-built_in">key</span>, value);\n    }\n  }\n}\n</code></pre>\n<p>这些规则仅限自定义属性, 如果是内置属性, 则又不同, 比如绑定 <code>class</code> 属性:</p>\n<pre><code class="hljs javascript">v-<span class="hljs-string">bind:</span><span class="hljs-class"><span class="hljs-keyword">class</span>="{</span><span class="hljs-string">active:</span> isActive}<span class="hljs-string">"</span>\n</code></pre>\n<p>则表示如果 <code>isActive</code> 值为是 <code>false</code> 或者是其他可以转换成布尔值 <code>false</code> 的值, 则 <code>active</code> 这个类名不应用, 反之, 则应用该类名(同 if 语句的真假判定一致).</p>\n<h2 id="-">过滤器</h2>\n<p>过滤器串联起来的话, 第一个过滤器的参数是初始值, 随后的过滤器第一个参数为上一个过滤器的返回值, 没有返回值则为 <code>undefined</code>.</p>\n<p>模板:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">div</span> v-bind:<span class="hljs-keyword">prop</span>=<span class="hljs-string">"rawProp | filterOne | filterTwo"</span>&gt;控制台查看 filter 函数的参数&lt;/<span class="hljs-keyword">div</span>&gt;\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  data(){\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">rawProp</span>: <span class="hljs-string">\'this is raw prop\'</span>\n    }\n  },\n  <span class="hljs-attr">filters</span>: {\n    filterOne(){\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'this param is pass to next filter\'</span>\n    },\n    filterTwo(){\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);\n    },\n  },\n  <span class="hljs-attr">name</span>: <span class="hljs-string">\'com-header\'</span>,\n}\n</code></pre>\n<p>除了第一个 <code>filter</code> ,后面的 <code>filter</code> 没有办法获取到初始值. 当然, 如果你想传参数, 办法有的是, 比如第一个 <code>filter</code> 返回一个数组等等.</p>\n<h2 id="-">列表渲染</h2>\n<p><code>v-for</code> 中, 如果参数是两个, 则是和原生 <code>js</code> 中的 <code>forEach</code> 参数一致, 是 <code>value, key</code>, 而使用 <code>of</code> 操作符和使用 <code>in</code> 操作符的效果完全一样------虽然在原生 <code>js</code> 中并不是.</p>\n<p>还有个需要注意的地方是, 组件使用 <code>v-for</code> 的时候, 父级是不能自动传递数据到组件的, 因为组件有自己的独立作用域. 因此你为了传递数据给子组件用, 需要使用 <code>props</code> 属性写的稍微麻烦一点:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">my</span>-component\n  v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(item, index) in items"</span>\n  v-<span class="hljs-keyword">bind</span>:item=<span class="hljs-string">"item"</span>\n  v-<span class="hljs-keyword">bind</span>:<span class="hljs-keyword">index</span>=<span class="hljs-string">"index"</span>&gt;\n&lt;<span class="hljs-regexp">/my-component&gt;</span>\n</code></pre>\n<p>另外, <code>v-for</code> 使用在对象上面的时候, 迭代值是对象的值, 而不是键, 这个和原生 <code>js</code> 不一样, 原生 <code>js</code> 的 <code>for in</code> 循环若要输出值, 需要你手动遍历 <code>obj[&#39;i&#39;]</code>, 而想要输出键需要写第二个参数<code>(value, key)</code>:</p>\n<pre><code class="hljs js">obj:{\n  first: <span class="hljs-string">\'xheldon\'</span>,\n  last: <span class="hljs-string">\'cao\'</span>,\n  age: <span class="hljs-string">\'25\'</span>\n}\n&lt;div v-for=<span class="hljs-string">"(value, key) in obj"</span>&gt;{% raw %}{{value}}-{{key}}{% endraw %}&lt;/div&gt;// 输出 xheldon cao <span class="hljs-number">25</span>\n</code></pre>\n<p>注意, 原生 <code>js</code> 除非你手动实现了一个 <code>Symbol.iterator</code>, 否则是不能使用 <code>for of</code> 循环的, 但是 <code>Vue</code> 可以------虽然效果和 <code>for in</code> 完全一样.</p>\n<p>列表渲染还有一个小 <code>tips</code> 叫就地复用原则, 什么意思呢? 还是拿上面说的 <code>tololist</code> 说, 如果没有给每个元素指定一个独一无二的 <code>key</code> 值, 就像这样:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, key) in todolist"</span>&gt;</span></span><span class="hljs-template-variable">{{value.key}}</span><span class="xml">:</span><span class="hljs-template-variable">{{value.value}}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"deletetodo(key)"</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>\n</code></pre>\n<p>那么每次点击这个叉叉删除当前 <code>li</code> 的时候, <code>Vue</code> 都会就地复用当前的元素, 直接移动数据到正确的位置, 而不是 <code>remove</code> 删除的 <code>dom</code> 元素, 避免 <code>reflow</code>, 下面是使用 <code>chrome</code> 的 <code>devtool</code> 工具显示的当点击叉叉删除元素的时候, 页面 <code>render</code> 的情况:</p>\n<p><img src="http://img.xheldon.com/img/nokey.png" alt="没有key" title="没有key"></p>\n<p>可以看到 <code>reflow</code> 的部分只有最下面那一点</p>\n<p>而当加上 <code>key</code> 之后:</p>\n<pre><code class="hljs html">&lt;li <span class="hljs-attribute">v-for</span>=<span class="hljs-string">"(value, key) in todolist"</span> :<span class="hljs-attribute">key</span>=<span class="hljs-string">"value.key"</span>&gt;{%<span class="hljs-built_in"> raw </span>%}{{value.key}}:{{value.value}}{% endraw%}&lt;button @<span class="hljs-attribute">click</span>=<span class="hljs-string">"deletetodo(key)"</span>&gt;X&lt;/button&gt;&lt;/li&gt;\n</code></pre>\n<p>再看点击叉叉之后浏览器的 <code>render</code> 的情况:</p>\n<p><img src="http://img.xheldon.com/img/key.png" alt="有key" title="有key"></p>\n<p>有人可能会有疑惑, 为什么这个地方需要自己手动实现一个 <code>value</code> 上的 <code>value.key</code>, 而不是使用 <code>Vue</code> 给的 <code>(value, key)</code> 中的 <code>key</code> 呢?:</p>\n<pre><code class="hljs html">{%<span class="hljs-built_in"> raw </span>%}\n&lt;li <span class="hljs-attribute">v-for</span>=<span class="hljs-string">"(value, key) in todolist"</span> :<span class="hljs-attribute">key</span>=<span class="hljs-string">"key"</span>&gt;{{value.key}}:{{value.value}}&lt;button @<span class="hljs-attribute">click</span>=<span class="hljs-string">"deletetodo(key)"</span>&gt;X&lt;/button&gt;&lt;/li&gt;\n{% endraw %}\n</code></pre>\n<p>答案是, <code>Vue</code> 给的 <code>key</code>, 看起来是个 <code>key</code>, 但是还是跟当前数据是无关的, 因此当删除一个 <code>li</code> 的时候, <code>key</code> 仅仅只是重新算了一下, 并没有跟着删除的或者被删除的元素移除或者上移下移. 如果使用上面的写法, 效果和第一种没有 <code>key</code> 的是一样的, 仍然使用了就地复用策略, 变动的还是数据, 不变的还是 <code>dom</code> 结构, 因此你需要手动实现一个 <code>key</code>, 大致是这样的:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">data</span>(){\n  <span class="hljs-keyword">return</span>{\n    toolist:[],\n    truekey: <span class="hljs-number">0</span>,<span class="hljs-comment">//手动实现一个 key</span>\n    todotext: <span class="hljs-string">\'\'</span>\n  }\n},\nmethods: {\n  addTolist(){\n    <span class="hljs-keyword">this</span>.todolist.push({value:<span class="hljs-keyword">this</span>.todotext, key: ++<span class="hljs-keyword">this</span>.truekey});<span class="hljs-comment">// 把 key 放到 data 上</span>\n  }\n}\n</code></pre>\n<h2 id="-">事件处理器</h2>\n<p>事件处理器可以串联, 但是有些元素本身不支持, 因此绑定了也没有意义, 如在 <code>div</code> 上绑定一个 <code>keyup</code> 事件:</p>\n<pre><code class="hljs javascript">&lt;<span class="hljs-selector-tag">div</span> @keyup.alt=<span class="hljs-string">"pressalt"</span>&gt;<span class="hljs-selector-tag">div</span> alt 按键测试&lt;/div&gt;\n</code></pre>\n<p>因此一般是在 <code>div</code> 上冒泡处理事件, 然后在一个 <code>input</code> 上绑定一个 <code>alt+ctrl</code> 事件:</p>\n<pre><code class="hljs javascript">&lt;<span class="hljs-keyword">div</span> @keyup.alt=<span class="hljs-string">"presskey"</span>&gt;<span class="hljs-keyword">div</span>冒泡按键测试\n  &lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span>&gt;\n&lt;/<span class="hljs-keyword">div</span>&gt;\n</code></pre>\n<p>我对此有个担心, 就是如果一个 <code>input</code> 使用了 <a href="mailto:`@keyup.space">`@keyup.space</a><code>的监听, 但是中文输入法中空格一般是用来选中词语的, 那实际输出的是还未选中词语的拼音字母, 还是按下空格后, 候选列表的第一个词语呢?(貌似这个不是</code>Vue` 的问题, 但是还是在这儿提出来了)</p>\n<p>答案是, 大多数情况下, 结果是按下空格后的第一个词语, 但是如果一句话很长的话, 需要按两次 <code>space</code> 来输出一句话, 则第一次按的时候, 什么也不会输出, 是个空的, 第二次按下 <code>space</code> 才输出全部的词汇. 我这里是为了测试的极端情况, 因此基本可以认为按下空格后的第一个词语, 而不是空白, 或者拼音字母. 我使用的是搜狗 <code>mac</code> 输入法的单行候选词模式, 可以用上面的 <code>todolist</code> 来测试(略)</p>\n<p>注: 官网文档讲 <code>v-model</code> 的时候会讲到 <code>IME</code>, 说的就是这个问题, 如果希望使用输入法的时候, <code>v-model</code> 也即时响应, 那么可以绑定 <code>input</code> 事件.</p>\n<h2 id="-">表单控件</h2>\n<p><code>v-model</code> 一般用在 <code>input</code> 上面, 而模板中的 <code>input</code> 的 <code>value</code> 值会被忽略------ <code>v-model</code> 只认在 <code>js</code> 中的初始值, 并与之绑定, 因此如果你写了 <code>v-model</code>, 又写了 <code>value</code> 属性, 则后者虽然会出现在 <code>dom</code> 结构中, 但是 <code>js</code> 获取其值的时候会忽略掉它而取 <code>v-model</code> 绑定的值:</p>\n<pre><code class="hljs html">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">"我出现在 dom 结构的 value 属性中, 但是只能通过 getAttribute 获取到我, .value 并不能获取到, 伤心~"</span>&gt;\n</code></pre>\n<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">data</span>(){\n  <span class="hljs-title">return</span>{\n    <span class="hljs-title">todotext</span>:\'我是真正的初始值, <span class="hljs-title">js</span> 获取的是我, 虽然我并不出现在 <span class="hljs-title">dom</span> 中的 <span class="hljs-title">value</span> 属性中~\',\n  }</span>\n}\n</code></pre>\n<p>二者的区别类似于 <code>jQuery</code> 中的, <code>.data</code> 和 <code>.attr</code> 的区别------写在行内的是 <code>attr(&#39;data&#39;,&#39;xxx&#39;)</code>的值, 查看 <code>dom</code> 结构看到的也是 <code>xxx</code> 的值, 但是 <code>js</code> 获取到的实际的值是通过 <code>js</code> 绑定的 <code>.data(&#39;yyy&#39;)</code> 的值------当然除非你使用 <code>attr</code> 读取 <code>dom</code> 结构.(注意, 实例化之后再修改 <code>attr</code> 的值, <code>js</code> 获取到的就是 <code>attr</code> 的值了, 这里的忽略初始值, 仅仅是忽略初始值而已, 举个例子就是初始化之后的 <code>v-model</code> 绑定了 <code>value</code> 之后, 手动修改 <code>dom</code> 结构的 <code>value</code> 值, 那 <code>v-model</code> 再获取该元素的 <code>value</code> 值就会使用修改后的 <code>attr</code> 属性值, 而不是 <code>data</code> 上面的值).</p>\n<p>如果需求比较奇葩, 不想通过 <code>v-model</code> 获取 <code>input</code> 的值, 然后实时更新, 或者需要获取 <code>input</code> 的值处理后再更新, 同时不想使用 <code>v-model</code>, 可以试试 <code>$ref</code>(<code>e.target.value</code> 也是可以的):</p>\n<p>模板:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">input</span> @<span class="hljs-keyword">input</span>=<span class="hljs-string">"input"</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">"inputvalue"</span> /&gt;\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">data</span>(){\n  message: <span class="hljs-string">\'\'</span>\n},\nmethods:{\n  input(){\n    <span class="hljs-keyword">this</span>.message = <span class="hljs-keyword">this</span>.$refs.inputvalue.value;\n  }\n}\n</code></pre>\n<p>官网文档也说了, <code>v-model</code> 只是一个实现双向数据绑定的语法糖:</p>\n<pre><code class="hljs html">&lt;input v-bind:<span class="hljs-attribute">value</span>=<span class="hljs-string">"something"</span> v-on:<span class="hljs-attribute">input</span>=<span class="hljs-string">"something = <span class="hljs-variable">$event</span>.target.value"</span>&gt;\n</code></pre>\n<p>不过监听 <code>input</code> 事件, 导致的问题是使用输入法的时候, 在没按空格选中词语的时候, 也会触发输入的事件, 所以如果没有这个需求, 还是老老实实用 <code>v-model</code> 的好.</p>\n<p>如果需要多个元素绑定相同的值并输出, 常见的需求是一组 <code>checkbox</code>, 这个时候需要使用数组:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-built_in">input</span> v-model=<span class="hljs-string">"messages"</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">"checkbox"</span> value=<span class="hljs-string">"xheldon"</span> /&gt;\n&lt;<span class="hljs-built_in">input</span> v-model=<span class="hljs-string">"messages"</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">"checkbox"</span> value=<span class="hljs-string">"xiaodan"</span> /&gt;\n<span class="hljs-symbol">&lt;p&gt;</span>{{<span class="hljs-keyword">messages</span>}}&lt;/<span class="hljs-keyword">p</span>&gt;\n</code></pre>\n<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">data</span>(){\n  <span class="hljs-title">return</span>{\n    <span class="hljs-title">messages</span>: []\n  }</span>\n}\n</code></pre>\n<p>(目前我发现的)这种如此简洁的数组用法仅仅对多个 <code>checkbox</code> 类型的 <code>input</code> 有效------即几个元素绑定相同的 <code>v-model</code>, 但是这几个元素的状态却没有同步, 而是将对应的 <code>value</code> 放到数组中. 当然如果你强行说, 我用 <code>methods</code> 方法可以实现任意输入类型的元素完成类似效果------那当我没说.</p>\n<p>单个的 <code>checkbox</code> <code>v-model</code> 绑定的是 <code>value</code> 值, 为 <code>true</code> 或者 <code>false</code>, 可以通过 <code>:true-value</code> 和 <code>:false-value</code> 来自定义选中时候的值和没有选中时候的值.</p>\n<p>而多个单选框 <code>radio</code> 中的 <code>v-model</code> 起到了类似 <code>name</code> 的作用------即用来分组, 所以 <code>radio</code> 类型的 <code>input</code> 使用 <code>v-model</code> 的话就不用写 <code>name</code> 属性.</p>\n<p><code>select</code> 类型的如果没有给定每个 <code>option</code> 的 <code>value</code> 属性, 则绑定的是 <code>option</code> 中的值, 如果给了则就是 <code>value</code> 的属性值. <code>select</code> 类型的多选框 <code>v-model</code> 绑定的 <code>data</code> 必须是一个数组类型, 否则会给出警告(但不会报错, <code>Vue</code> 自动转换, 还是能正常运行):</p>\n<pre><code class="hljs javascript"><span class="hljs-symbol">Vue</span> warn]: &lt;<span class="hljs-keyword">select </span><span class="hljs-keyword">multiple </span>v-model=<span class="hljs-string">"selectM"</span>&gt; expects an Array value for <span class="hljs-keyword">its </span><span class="hljs-keyword">binding, </span><span class="hljs-keyword">but </span>got <span class="hljs-keyword">String </span>\n</code></pre>\n<p>注意, 以上所有类型的 <code>v-model</code> 和 <code>value</code> 绑定时, 而 <code>value</code> 属性又动态 (<code>:value=&quot;xxx&quot;</code>)绑定了 <code>data</code> 上的其他(<code>xxx</code>)属性, 则 <code>v-model</code> 对应的属性和 <code>:value</code> 对应的属性是同一个(严格相等).</p>\n<h2 id="-">组件</h2>\n<p>首先需要区分的是, 什么是 <code>DOM</code> 模板, 什么是字符串模板.</p>\n<p><code>HTML</code> 模板指的是普通的 <code>html</code> 中的元素, 这些元素会通过 <code>Vue</code> 实例的 <code>el</code> 选项进行绑定:\n字符串模板部分:</p>\n<pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">"tpl"</span>&gt;  实例挂载元素\n  html 自有组件:\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>\n  自定义组件:\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n</code></pre>\n<p>字符串模板指的是:</p>\n<p>1.<code>js</code> 中通过 <code>template</code> 注册的模板如: </p>\n<pre><code class="hljs javascript"><span class="hljs-selector-tag">Vue</span><span class="hljs-selector-class">.component</span>(<span class="hljs-string">\'my-component\'</span>, {\n  <span class="hljs-attribute">template</span>: <span class="hljs-string">\'&lt;span&gt;{{message}}&lt;/span&gt;\'</span>,\n  data(){\n    <span class="hljs-attribute">message</span>: <span class="hljs-string">\'hello, xheldon\'</span>\n  }\n});\n</code></pre>\n<p>或者:</p>\n<pre><code class="hljs javascript">var Child = {\n  template: <span class="hljs-string">\'&lt;div&gt;\'</span>hello, xheldon<span class="hljs-string">\'&lt;/div&gt;\'</span>\n}\nnew Vue({\n  components: {\n    <span class="hljs-string">\'my-component\'</span>: Child\n  }\n})\n</code></pre>\n<p>2.通过<code>&lt;script type=&quot;text/x-tempalge&quot;&gt;&lt;/script&gt;</code>注册的模板(和 <code>Handlebar</code> 一样)</p>\n<p>3.<code>.vue</code> 组件中的 <code>&lt;template&gt;</code> 标签内的内容.</p>\n<p>因为 <code>Vue</code> 是在浏览器解析完毕之后才开始解析 <code>DOM</code> 模板的, 因此 <code>DOM</code> 模板在一些需要特定子元素的标签上不能使用组件. 如 <code>select</code> 标签下的子元素必须为 <code>option</code>, 因此用自定义标签 <code>com-option</code> 则不会识别, 因此可以增加一个 <code>is=&quot;component-name&quot;</code> 属性, 表明该标签使用的模板名字即可.</p>\n<h2 id="-vs-">字面量语法 VS 动态语法</h2>\n<p>这里需要注意个问题, 即在原生 <code>js</code> 中, 对象的属性是可以为数字的, 只是其会被当成是字符串(仅限 <code>ES5</code>, <code>ES6</code> 中对象属性可以为任意值, 不过和之后要说的不冲突). 但是在 <code>Vue</code> 中, <code>data</code> 属性上不能使用数字作为属性, 如果是字面量语法, 传递数字会被先 <code>toString</code> 处理, 而如果是动态语法, 则会直接当做是数字处理, 不会寻找 <code>data</code> 上绑定的属性值:</p>\n<p>子组件模板:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">{{dynamic}}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"alertProp"</span>&gt;</span> 点我看上面 props 传参的类型<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n</code></pre>\n<p>子组件逻辑:</p>\n<pre><code class="hljs javascript">props:[<span class="hljs-string">\'dynamic\'</span>],\nmethods:{\n  alertProp(){\n    alert(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">dynamic</span>)<span class="hljs-comment">//上面说过了, props 属性也是绑定到 Vue 实例上的, 因此可以直接使用 this</span>\n  }\n}\n</code></pre>\n<p>父组件-字面量语法:</p>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">com-child</span> <span class="hljs-attr">dynamic</span>=<span class="hljs-string">"11"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com-todolist</span>&gt;</span>\n</code></pre>\n<p>父组件-动态语法:</p>\n<pre><code class="hljs html">&lt;com-child <span class="hljs-symbol">:dynamic=<span class="hljs-string">"11"</span>&gt;&lt;/com-todolist&gt;</span>\n</code></pre>\n<p>以上两种语法下父组件逻辑均为:</p>\n<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">data</span>(){\n  <span class="hljs-title">return</span> {\n    11:\'属性-动态语法\'\n  }</span>\n}\n</code></pre>\n<p>结果是, 当使用父组件字面量语法毫无疑问点击 <code>button</code> 的时候传递给子组件的是 <code>1</code>, 而且文档也说了, 是字符串的 <code>1</code>, 因此 <code>alert</code> 出来的是 <code>string</code>; 而当父组件动态语法使用 <code>v-bind</code> 绑定了父组件 <code>data</code> 的 <code>1</code> 属性, 但是子组件并没有接收到 <code>1</code> 属性对应的 <code>属性-动态语法</code> 这个值, 而还是 <code>1</code> 这个值,  因此点击 <code>button</code> 时候 <code>alert</code> 出来的是 <code>number</code>.</p>\n<p>结论: 最好不要使用数字作为 <code>data</code> 对象的属性.</p>\n<p>注意: 如果传递给子组件属性的是一个数组或者对象, 在子组件中修改这个属性值, 则会反映到父组件上------这通常是不应该的, 因为俗话说得好: <code>props down, events up</code>(举例略), 最佳实践应该是使用父组件传递过来的引用类型的深拷贝------当然如果你就是需要子组件影响父组件的状态, 那我祝你好运.</p>\n<p><code>events up</code> 的时候, 如果子组件 <code>$emit</code> 的时候传递了除了事件名之外的其他参数, 则这些参数会被传递给父组件的事件监听函数:</p>\n<p>子组件模板:</p>\n<pre><code class="hljs javascript"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">"someEventHandlerForOriginalEventLikeClickOrInput($event)"</span>/&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">{{data}}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>\n</code></pre>\n<p>子组件逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-string">props:</span>[<span class="hljs-string">\'data\'</span>],\n<span class="hljs-string">methods:</span>{\n  someEventHandlerForOriginalEventLikeClickOrInput(e){\n    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'eventPasstoParent\'</span>, e.target.value, <span class="hljs-string">\'someOtherArgus\'</span>);\n  } \n}\n</code></pre>\n<p>父级模板:</p>\n<pre><code class="hljs html">&lt;com-todolist :<span class="hljs-attribute">data</span>=<span class="hljs-string">"someParentData"</span> @<span class="hljs-attribute">eventPasstoParent</span>=<span class="hljs-string">"someParentEventHandler"</span>&gt;&lt;/com-todolist&gt;\n</code></pre>\n<p>父级逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-string">someParentData:</span> <span class="hljs-string">\'\'</span>\n<span class="hljs-string">methods:</span>{\n  someParentEventHandler(){\n    <span class="hljs-keyword">this</span>.someParentData = [...arguments];\n  } \n}\n</code></pre>\n<h2 id="-">异步更新队列</h2>\n<p>有了 <code>Vue</code>, 就不再需要 <code>jQuery</code> 了, 框架的最大好处是避免了我们对相同操作的写出重复的代码. 双向数据绑定可以帮我们解决很多 <code>DOM</code> 操作问题, 但是有些情况下 <code>jQuery</code> 却更有优势, 比如操作 <code>DOM</code> 的时候, <code>jQuery</code> 会接收一个函数作为回调函数, 动画执行完成的时候触发. 而我们使用的双向数据绑定, 设置完数据之后, 如何知道 <code>DOM</code> 已经更新了呢? 答案和 <code>jQuery</code> 一样, 就是异步更新队列.</p>\n<pre><code class="hljs javascript">var <span class="hljs-keyword">vm</span> = <span class="hljs-keyword">new</span> Vue({\n  <span class="hljs-keyword">e</span><span class="hljs-variable">l:</span> <span class="hljs-string">\'#example\'</span>,\n  dat<span class="hljs-variable">a:</span> {\n    message: <span class="hljs-string">\'123\'</span>\n  }\n})\n<span class="hljs-keyword">vm</span>.message = <span class="hljs-string">\'new message\'</span> // 更改数据\n<span class="hljs-keyword">vm</span>.$<span class="hljs-keyword">el</span>.textContent === <span class="hljs-string">\'new message\'</span> // false\nVue.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>\n  <span class="hljs-keyword">vm</span>.$<span class="hljs-keyword">el</span>.textContent === <span class="hljs-string">\'new message\'</span> // true\n})\n</code></pre>\n<p>这么写我个人是不推荐的, 因为我认为最好的逻辑是写到实例的属性/方法里面, 而不是写到实例的外面, 还好 <code>Vue</code> 给我们提供了实现方式:</p>\n<pre><code class="hljs javascript">Vue.component(<span class="hljs-string">\'example\'</span>, {\n  <span class="hljs-attr">template</span>: <span class="hljs-string">\'&lt;span&gt;{{ message }}&lt;/span&gt;\'</span>,\n  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">message</span>: <span class="hljs-string">\'not updated\'</span>\n    }\n  },\n  <span class="hljs-attr">methods</span>: {\n    <span class="hljs-attr">updateMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">this</span>.message = <span class="hljs-string">\'updated\'</span>\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$el.textContent) <span class="hljs-comment">// =&gt; \'没有更新\'</span>\n      <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$el.textContent) <span class="hljs-comment">// =&gt; \'更新完成\'</span>\n      })\n    }\n  }\n})\n</code></pre>\n<h2 id="-">动画</h2>\n<p>动画没什么好说的, 主要是 <code>JavaScript</code> 钩子函数中的两个钩子需要说下, 一个是 <code>enterCanceled</code> 和 <code>leaveCancelled</code>. <code>enterCancelled</code> 在 <code>v-if</code> 和 <code>v-show</code> 中使用, 均可能触发, 而触发时机, 是触发 <code>enter</code> 的事件之后, 在动画还没有执行完的过程中, 又需要执行其他动画的时候. 而 <code>leaveCancelled</code> 只用于 <code>v-show</code> 中, 在 <code>v-if</code> 中使用时无效的, 永远不会被触发, 其触发时机是在离开动画(即 <code>xxx-leave-active</code> 动画)播放未完成的时候, 又执行了其他动画的时候触发.</p>\n<p>测试代码:</p>\n<pre><code class="hljs html">&lt;button <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"button"</span> <span class="hljs-meta">@click</span>=<span class="hljs-string">"show=!show"</span>&gt;点击我切换状态&lt;/button&gt;\n&lt;transition name=<span class="hljs-string">"go"</span>\n  <span class="hljs-meta">@before</span>-enter=<span class="hljs-string">"beforeEnter"</span>\n  <span class="hljs-meta">@enter</span>=<span class="hljs-string">"enter"</span>\n  <span class="hljs-meta">@after</span>-enter=<span class="hljs-string">"afterEnter"</span>\n  <span class="hljs-meta">@enter</span>-cancelled=<span class="hljs-string">"enterCancelled"</span>\n  <span class="hljs-meta">@before</span>-leave=<span class="hljs-string">"beforeLeave"</span>\n  <span class="hljs-meta">@leave</span>=<span class="hljs-string">"leave"</span>\n  <span class="hljs-meta">@after</span>-leave=<span class="hljs-string">"afterLeave"</span>\n  <span class="hljs-meta">@leave</span>-cancelled=<span class="hljs-string">"leaveCancelled"</span>\n&gt;\n此处使用 v-show, 修改成 v-<span class="hljs-keyword">if</span> 的时候发现, leave-cancelled 不会触发.\n&lt;p v-show=<span class="hljs-string">"show"</span>&gt;\n  点击展示我, 再点击一下隐藏我.\n&lt;/p&gt;\n&lt;/transition&gt;\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-selector-tag">data</span>(){\n  <span class="hljs-selector-tag">return</span>{\n    <span class="hljs-attribute">show</span>: true\n  }\n},\n<span class="hljs-attribute">methods</span>: {\n  beforeEnter(){alert(<span class="hljs-number">1</span>);},\n  <span class="hljs-selector-tag">enter</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">2</span>);},\n  <span class="hljs-selector-tag">afterEnter</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">3</span>);},\n  <span class="hljs-selector-tag">enterCancelled</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">4</span>);},\n  <span class="hljs-selector-tag">beforeLeave</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">5</span>);},\n  <span class="hljs-selector-tag">leave</span>(){<span class="hljs-selector-tag">alert</span>(<span class="hljs-number">6</span>);},\n  <span class="hljs-selector-tag">afterLeave</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">7</span>);},\n  <span class="hljs-selector-tag">leaveCancelled</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">8</span>);}\n},\n</code></pre>\n<p>样式:</p>\n<pre><code class="hljs css"><span class="hljs-selector-class">.button-animate</span> <span class="hljs-selector-tag">button</span>{\n  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40px</span>;\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;\n  <span class="hljs-attribute">position</span>: absolute;\n}\n<span class="hljs-selector-class">.go-enter-active</span> {\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">5s</span> ease;\n}\n<span class="hljs-selector-class">.go-leave-active</span> {\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(1.0, 0.5, 0.8, 1.0);\n}\n<span class="hljs-selector-class">.go-enter</span>, <span class="hljs-selector-class">.go-leave-active</span> {\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(10px);\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n}\n</code></pre>\n<p>钩子们的参数除了 <code>enter</code> 和 <code>leave</code> 是 <code>el</code> 元素本身(原生的 <code>Element</code> 类型元素), 和 <code>done</code> 回调函数外, 其他钩子的参数均为 <code>el</code> 元素本身.</p>\n<p>元素的过渡, 最好给每个元素加个 <code>key</code>, 因为之前提到的就地复用策略, 可能在切换的时候直接替换数据, 没有动画效果.</p>\n<p>在官方文档中完全没有说明的一点是, <code>Vue transition</code> 的动画类名 <code>css</code> 的写法是有顺序限制的, <code>v-enter</code> 和 <code>v-leave</code> 必须写在 <code>v-enter-active</code> 和 <code>v-leave-active</code> 的后面, 否则无效, 比如我想写一个点击按钮的淡入淡出效果, 点击按钮之后会有一个按钮从左向右淡入, 同时当前点击的按钮任从左往右淡出:\n逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">data</span>:{\n  isShow: <span class="hljs-literal">true</span>\n},\nmethods:{\n  animakkey(){\n    <span class="hljs-keyword">this</span>.isShow = !<span class="hljs-keyword">this</span>.isShow;\n  } \n}\n</code></pre>\n<p>结构:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">"button-animate"</span>&gt;\n  &lt;<span class="hljs-attribute">transition</span> name=<span class="hljs-string">"go"</span>&gt;\n    &lt;<span class="hljs-selector-tag">button</span> key=<span class="hljs-string">"a"</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"isShow"</span> @click=<span class="hljs-string">"animakkey"</span>&gt;on&lt;/button&gt;\n    &lt;<span class="hljs-selector-tag">button</span> key=<span class="hljs-string">"b"</span> v-<span class="hljs-keyword">else</span> @click=<span class="hljs-string">"animakkey"</span>&gt;off&lt;/button&gt;\n  &lt;/<span class="hljs-attribute">transition</span>&gt;\n&lt;/div&gt;\n</code></pre>\n<p>如果你的样式是这样的:</p>\n<pre><code class="hljs css"><span class="hljs-selector-class">.button-animate</span> <span class="hljs-selector-tag">button</span>{\n  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40px</span>;\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;\n  <span class="hljs-attribute">position</span>: absolute;\n}\n<span class="hljs-selector-class">.go-enter</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-25px);\n}\n<span class="hljs-selector-class">.go-leave</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(25px);\n}\n<span class="hljs-selector-class">.go-enter-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(0px);\n}\n\n<span class="hljs-selector-class">.go-leave-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(50px);\n}\n</code></pre>\n<p>会发现动画效果并不如意:</p>\n<p><img src="http://img.xheldon.com/img/animateBad.gif" alt="animate" title="animate"></p>\n<p>而如果把 <code>enter</code> 放到 <code>enter-active</code> 的后面:</p>\n<pre><code class="hljs css"><span class="hljs-selector-class">.button-animate</span> <span class="hljs-selector-tag">button</span>{\n  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40px</span>;\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;\n  <span class="hljs-attribute">position</span>: absolute;\n}\n<span class="hljs-selector-class">.go-enter-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(0px);\n}\n<span class="hljs-selector-class">.go-enter</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-25px);\n}\n<span class="hljs-selector-class">.go-leave-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(50px);\n}\n<span class="hljs-selector-class">.go-leave</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(25px);\n}\n</code></pre>\n<p>就完美了:</p>\n<p><img src="http://img.xheldon.com/img/animateGood.gif" alt="animate" title="animate"></p>\n<p>在对比了这四个 <code>css</code> 类名的可能顺序之后, 发现只要 <code>v-enter</code> 放到 <code>v-enter-active</code> 的后面就能实现效果, 其他类名随意.</p>\n<p><code>transition</code> 标签中不能放其他元素而只能是放需要动画的元素, 如果上述示例结构写成这个样子:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-attribute">transition</span> name=<span class="hljs-string">"go"</span>&gt;\n&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">"button-animate"</span>&gt;\n  &lt;<span class="hljs-selector-tag">button</span> key=<span class="hljs-string">"a"</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"isShow"</span> @click=<span class="hljs-string">"animakkey"</span>&gt;on&lt;/button&gt;\n  &lt;<span class="hljs-selector-tag">button</span> key=<span class="hljs-string">"b"</span> v-<span class="hljs-keyword">else</span> @click=<span class="hljs-string">"animakkey"</span>&gt;off&lt;/button&gt;\n&lt;/div&gt;\n&lt;/<span class="hljs-attribute">transition</span>&gt;\n</code></pre>\n<p>则不会有任何动画效果, 而如果在正常 <code>css</code> 类名中使用一些 <code>css</code> 属性规定了元素的样式, 而在动画类名如 <code>v-enter</code> 中又使用了相同的属性, 则也不会生效, <a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名" target="_blank">文档</a>说&quot;他们的优先级高于普通的类名&quot;, 实则不然(也不知道是我理解错误?欢迎指正), 还是上例, 样式中, 设置 <code>button</code> 的正常 <code>css</code> 属性:</p>\n<pre><code class="hljs css"><span class="hljs-selector-class">.button-animate</span> <span class="hljs-selector-tag">button</span>{\n  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40px</span>;\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;\n  <span class="hljs-attribute">position</span>: absolute;\n  <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateX</span>(50px);\n}\n<span class="hljs-selector-class">.go-enter-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(0px);\n}\n<span class="hljs-selector-class">.go-enter</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-25px);\n}\n<span class="hljs-selector-class">.go-leave-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(50px);\n}\n<span class="hljs-selector-class">.go-leave</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(25px);\n}\n</code></pre>\n<p>结果:</p>\n<p><img src="http://img.xheldon.com/img/animateWithout.gif" alt="animate" title="animate"></p>\n<p>可以看到, 只有 <code>opacity</code> 产生了动画, <code>transform</code> 没有动画!(同学们可以测试下是用 <code>animate.css</code> 的时候, 使用 <code>Animate.css</code> 中相同的属性来提前设置元素, 是否还有动画效果, 欢迎提 <code>issue</code>.)</p>\n<p><code>transition-group</code> 和 <code>transition</code> 有点不太一样, 从外观上说, <code>transition</code> 本身只是个包裹容器, 不参与任何的页面构成, 但是 <code>transition-group</code> 却会被 <code>Vue</code> 替换为一个标签, 默认是 <code>span</code> 标签, 也可以定制被替换成的标签名.</p>\n<h2 id="render-"><code>render</code> 函数</h2>\n<p>使用 <code>render</code> 函数可以代替写模板的作用, 其形参 <code>createElement</code> 一般被写成 <code>h</code>, 在组件或者标签内的各种绑定/属性等, 在 <code>createElement</code> 中都能找到对应的 <code>JavaScript</code> 写法, 如果找不到, 那就说明可以使用原生的写法, 比如 <code>.stop</code>, <code>.prevent</code> 等, 直接使用 <code>event.stopPropagation()</code> 和 <code>event.preventDefault()</code> 即可.</p>\n<h2 id="-">其他</h2>\n<p>混合(<code>mixin</code>), 就是指在写正常的组件过程中(也即在组件的生命周期中), 修改或者添加额外的功能.</p>\n<p>部分<code>插件</code>就是根据上面的 <code>mixin</code> 写的, 除此之外的插件还有往 <code>Vue.prototype</code> 添加方法, 或者通过 <code>config</code> 添加一些全局的方法或者属性.</p>\n<p><code>路由</code>, 可以通过 <code>component</code> 的 <code>is</code> 属性来简单实现, 也可以直接写 <code>render</code> 函数根据不同路径渲染不同模板, 当然更复杂的需要第三方库了.</p>\n<p><code>状态管理</code>, 看示例是要加个 <code>wrap</code> 来记录每个状态改变的过程, 然后官方建议的最佳实践是即使你能直接复制给示例属性, 但是也最好通过函数来修改状态, 因为这让状态变得可追踪.</p>\n<p><code>单元测试</code>, 就是正常的单元测试, 没什么好说的.</p>\n<h2 id="-server-side-render-">服务端渲染(<code>Server Side Render</code>)</h2>\n<p>看了下思路, 基本上很简单, 就是首先在 <code>app.js</code> 中 <code>exports</code> 一个 <code>Vue</code> 实例, 然后新建一个页面模板文件 <code>index.html</code>(引入 <code>Vue.js</code> 和挂载 <code>Vue</code> 实例的方法 <code>$mount</code>, 官网同样也引入了 <code>app.js</code>, 是否需要待我验证下再说), 含有实例的挂载点(一个带有 <code>id</code> 属性的非空元素), 然后在服务端 <code>server.js</code> 都 <code>require</code> 过来, 用 <code>vue-server-renderer</code> 这个东西, 把 <code>app.js</code> 中 <code>exports</code> 出去的 <code>Vue</code> 实例渲染下, 再在返回给客户端的时候替换掉挂载点(一个带有 <code>id</code> 属性的非空元素, 因为 <code>app.js</code> 中的模板已经存在了)即可.</p>\n<p>服务端渲染的结果就是, 会在上述的挂载点(一个带有 <code>id</code> 属性的非空元素)加一个 <code>server-rendered=&quot;true&quot;</code> 的属性(通过右键查看页面源代码查看存在, 说明不是 <code>js</code> 动态添加的).</p>\n<p>服务端也支持流式渲染, 首先需要把 <code>html</code> 以挂载点(一个带有 <code>id</code> 属性的非空元素,如 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>)为分割点, <code>split</code> 一下, 分为 <code>ab</code> 两个部分, 而刚刚使用的 <code>vue-server-renderer</code> 的是把 <code>app.js</code> <code>renderToString</code> 了, 而为了支持流式渲染, 需要换个方法叫 <code>renderToStream</code>, 然后监听 <code>data</code> 事件, 附加到, <code>html</code> 的 <code>a</code> 部分的后面, <code>end</code> 事件之后, 再拼接上 <code>html</code> 的 <code>b</code> 部分, 最后再一并 <code>res.send</code> 出去.</p>\n<h2 id="-">后记</h2>\n<p>坐标帝都, <code>ping</code> <code>cn.vuejs.org</code>:</p>\n<p><img src="http://img.xheldon.com/img/ping1.png" alt="ping" title="ping"></p>\n<p><code>ping</code> 我司<code>FQ</code> <code>VPS</code>:</p>\n<p><img src="http://img.xheldon.com/img/ping2.png" alt="ping" title="ping"></p>\n<p><code>dig</code> 一下:</p>\n<p><img src="http://img.xheldon.com/img/dig1.png" alt="dig" title="dig"></p>\n<p>可以看到使用的是 <code>cloudflare</code> 的服务, 国际网站不好做呀, 呵呵.</p>\n'},301:function(s,e){s.exports='<h1 id="vue-">Vue 实现路由的三种方式</h1>\n<p>date:   2016-06-12 22:13:35 +0800</p>\n<h3 id="-vue-framework-">分类: [Vue, Framework]</h3>\n<hr>\n<p>Vue 学习总结基本告一个段落, 接下来会补充一些其他的碎片知识, 今天说下 Vue Router 的三种实现方式.</p>\n<p><a href="https://github.com/Xheldon/Framework/tree/master/VueSPA" target="_blank">查看项目完整代码</a>(本项目含有其他 Vue 测试代码如 Vue Plugin 等)</p>\n<h2 id="-render-">通过 render 函数</h2>\n<p>基本思路是, render 根据地址栏的路径渲染组件内容, 配合 HTML5 的 history.pushState 的使用, 以及 popstate 事件的监听, 可以实现直接访问地址/浏览器返回前进/点击链接跳转的路由功能.</p>\n<p>优点: </p>\n<ol>\n<li>可以将不存在的地址转到 404.vue 页面.</li>\n</ol>\n<p>缺点: </p>\n<ol>\n<li>不支持 HTML5 的 hostory.pushState API 的浏览器无法 Polyfill. </li>\n<li>render 函数的渲染无法缓存起来.</li>\n</ol>\n<p>注意: 如果使用动画过渡效果 transition, 则根元素存在于 default.vue 中, 注意代码中和下面的区别.</p>\n<p>可查看 <a href="https://github.com/Xheldon/Framework/tree/master/VueSPA/app/NoRouter" target="_blank">具体代码</a></p>\n<h2 id="-component-is-">通过 component 的 is 属性</h2>\n<p>其实原理和上面的一样, 只是把 render 函数换成了component.</p>\n<p>component 组件有个 is 属性, 用来指示该 component 加载哪一个模板, 该属性可以自己通过逻辑, 来根据地址栏地址动态设置.</p>\n<p>优点:</p>\n<ol>\n<li>component 可以加上 keep-alive 属性来缓存起来, 比上面的 render 函数高效.</li>\n</ol>\n<p>缺点: </p>\n<ol>\n<li>不支持 HTML5 的 hostory.pushState API 的浏览器无法 Polyfill. </li>\n<li>无法渲染不存在的路由地址(如404等, 因此可以看到该 Demo 下没有像上面一样的 404.vue)</li>\n</ol>\n<p>注意: 如果使用动画过渡效果 transition, 则根元素存在于 tpl.html 中, 注意代码中和上面的区别.</p>\n<p>可查看 <a href="https://github.com/Xheldon/Framework/tree/master/VueSPA/app/NoRouterWithIs" target="_blank">具体代码</a></p>\n<h2 id="-vuerouter-">通过 VueRouter 插件</h2>\n<p>VueRouter 是官方插件, 完美实现了各种需求.</p>\n<p>优点: </p>\n<ol>\n<li>该有的功能都有.</li>\n</ol>\n<p>缺点:</p>\n<ol>\n<li>为了 Polyfill pushState, 在路径后面加了个 # 来实现路由功能, 实则不是真正的路由, 只是更改 hash 值.</li>\n</ol>\n<p>可查看 <a href="https://github.com/Xheldon/Framework/tree/master/VueSPA/app/Router" target="_blank">具体代码</a></p>\n'},302:function(s,e){s.exports='<h1 id="-">一些牢骚</h1>\n<p>date:   2016-07-03 22:13:35 +0800</p>\n<h3 id="-think-">分类: [Think]</h3>\n<hr>\n<p>以下牢骚毫无逻辑性, 想到啥说啥.</p>\n<h2 id="-">在公司学习</h2>\n<p>公司欢迎你努力学习新技术, 但是前提是你先把自己工作上的事情做好, 公司给你钱是让你来干活的, 不是让你来学习的, 想学习回家学习. 有些实习生/应届生抱怨说公司给的工资低, 这是因为公司/同事在为你的不成熟的代码买单, 交代点简单的事儿半天没做完, 我要是领导早就炒了你了, 让你好好在家学习. 烦.</p>\n<h2 id="-">伸手党, 缺乏工程师思维</h2>\n<p>遇到问题第一反应是问别人, 而不是自己 google/stackoverflow/github/文档, 拜托, 你是工程师, 就得对得起工程师这个称号, 工程师是什么? 是用来解决现实问题的, 不是用来推脱问题的, 或者把问题交给别人的. 用乔布斯的话说, 工程师的任务就是, <code>fix it, that&#39;s your job</code>. 烦.</p>\n<h2 id="-">废话连篇</h2>\n<p>领导交代你的事情, 目的是让你给个结果, 然后领导来决策, 而不是你把各种问题给领导说了之后, 让领导自己分析. 比如领导明确交代, 把这个兼容性/实现难度给我试验下, 下班跟我说结果. 快下班了, 去汇报研究成果, 领导想听的就简单的几句话: <code>可以做</code>, 或者 <code>给定时间坐不了, 难点是 xxx</code>. 但是有些人的回答是: 哎呀, 这个问题挺复杂的, 网上有人说这个可以做, 但是我试验了下不太行, 不过我还一个思路, 是 blabla, 然后我试验了下, 确实可以但是效果不完美, 我还需要再改进下, 群里有人给我说了另一个思路, 我觉得也可行, 但是还没来得及试验, 然后又是一顿 blablabla. 我要是领导我就开除你了知道吗? 烦.</p>\n<h2 id="-">重复劳动</h2>\n<p>有个简单的重复性工作, 但是所需要的知识超出了自己的范围. 举个例子, 每次开一个新的项目, 都需要手动复制一些配置文件, 或者一些资源文件. 有些人看到了, 想着反正也不麻烦, 就一直这么复制着. 不能写个node cli? 不会 cli 不会学习一下? 学不会 cli 不能用已经有的, 比如 gulp/node/ruby/shell 简单实现一下? 很难? 机械劳动, 是不是程序员? 烦.</p>\n<h2 id="-">知其然不知其所以然</h2>\n<p>有些人, 热衷于学习各种 plugin 并以此为傲, 今天学会了这个 plugin, 去论坛吹嘘一番: 这个插件真好用, 听说你们还在用 xxx? 明天又学会了一个 API, 又在群里吹嘘一番: 这个 API 真好用啊, xxx 的 API 设计比起来就是垃圾, 结果平常私底下还会问一些诸如 JavaScript 函数传递参数是按值还是按引用的? return 语句在嵌套函数中是只返回一层, 还是直接返回到最外层函数? if 语句会被 break/return 跳出吗? 这种基本概念的问题. 会用 API 了不起? 看得懂文档, 傻逼也会用好吗? 能不能学好基础先? 烦.</p>\n<h2 id="-">智障</h2>\n<p>有些人, 写了个半成品, 赶紧让全世界都知道, 然后求别人 star 他, 注意是 <code>&quot;求&quot;</code> 好让不知道的人看他觉得很厉害. 烦.</p>\n<h2 id="-jb-">乱 JB 造轮子</h2>\n<p>不怕撕逼, 说的就是 eleme, 好好的 webpack 不用, 非得造个 cooking 打包, 让别人用你的东西, 显得你厉害是吧? 增加学习成本懂吗? 烦</p>\n<h2 id="-">妄议公司</h2>\n<p>我们公司是不是有点 xxx, 而且还 xxx, 你看 xxx 公司, 他们就很 xxx. 私底下议论就算了, 非得在电梯里面说, 电梯里面没人说也就说了, 非得在电梯里面很多人的时候说, 显得你能是不是? 发现公司问题不会发邮件给你领导然后抄送管理层? 烦.</p>\n<h2 id="-">菜鸡互啄</h2>\n<p>俗话说, 跟高手过招进步才能快. 但是有些人, 遇到一个问题, 问另一个人, 那个人也不太清楚, 于是就开始 blabla 讨论, 最后得出看似正确的结论. 然后下次遇到另一个问题还是问这个人. 我觉得跟一个人讨论技术问题, 说不了几句话基本就能判断这个人的技术水平的高低, 既然知道这个人技术不行, 那就不要像这个人请教了, 去找其他大神请教不行吗? 你们两个人讨论来讨论去, 讨论的有意义吗? 胜得过大神的一句结论性总结吗? 既浪费时间, 又毫无意义. 遇到问题, 自己解决不了的, 直接像大神说明自己的解决思路无果, 请大神指点就行了. 效率高而且有个权威性/结论性的总结, 印象更深刻. 就像上学的时候, 自学和老师教的区别一样, 自学一个自己总结出来的知识点总是不确定, 需要找其他题目练习来印证这个知识点, 但是如果这个知识点是老师说的, 根本不用再找题来验证, 直接使用这个知识点就行了. 而如果发现实际使用知识点的过程有问题, 如果是自学总结的知识点, 首先怀疑的是或许是自己总结的失误, 其次才是是否是知识点运用错误, 甚至是题目出错了. 恶如果是老师讲的知识点, 使用过程出现问题, 首先怀疑的是自己运用知识点错误, 而不是知识点本身错了. 正所谓: 吾尝终日而思矣, 不如须臾之所学也. 吾尝跂而望矣, 不如登高之博见也. 菜鸡互啄, 烦.</p>\n<h2 id="-">不专业</h2>\n<p>你工作的时候不专业就意味着别人为了和你完成任务就得付出更多, 就得为你的不专业买单, 浪费了大家的时间, 也惹得大家都不愉快. 当然都知道大家都是从未知到已知, 但是麻烦能不能吃一堑长一智, 或者多学习学习别人的工作方式, 避免相同的低级问题重复发生好吗? 烦.</p>\n<p>Ps: 以上只针对本人在生活中遇到的人和事, 不特指任何人, 看到了请不要对号入座, 由此造成的困扰, 发邮件, 本人看心情, 酌情承担.</p>\n<p>PPs: 如果有人中了以上每一点, 本人建议不要做工程师/程序员/码农, 早改行, 早走上人生巅峰.</p>\n'},303:function(s,e){s.exports='<h1 id="-cors-">我对 CORS 的探究</h1>\n<p>date:   2016-07-07 22:13:35 +0800</p>\n<h3 id="-javascript-">分类: [Javascript]</h3>\n<hr>\n<h2 id="-">本文由来</h2>\n<p>看网上某篇 <code>CORS</code> 资料的时候, 被一句话迷惑了: &#39;注意, 设置了 <code>withCredentials = true</code> 之后, 携带的 <code>cookie</code> 是目标域的 <code>cookie</code>&#39;, 我十分不解: 当前域假设为 <code>a.com</code> 发送 <code>xhr</code> 到 <code>b.com</code>, 当然是把源域 <code>a.com</code> 的 <code>cookie</code>, 发送给 <code>b.com</code> 来处理啊, 怎么会携带的是目标域(这里我理解为 <code>b.com</code>)的 <code>cookie</code> 呢? 因此我开始了探究(先说结论: 我查看的资料的说法确实是正确的, 携带的确实是目标域 <code>b.com</code> 的 <code>cookie</code>).</p>\n<h2 id="-1-a-com-ajax-b-com">小目标-1: 简单请求下让 <code>a.com</code> 发送 <code>ajax</code> 到 <code>b.com</code></h2>\n<p>什么是简单请求请自行谷歌/SO. 这里注意一个基本事实, <code>cookie</code> 是跟随着 <code>域名</code> 的, 而不是跟随着 <code>IP地址</code>, 我在本地起了一个简单的能处理 <code>cookie</code> 的 <code>express</code> 服务, 同时在我的 <code>VPS</code> 上也起了一个相同的服务, 然后通过修改 <code>hosts</code> 来实现不同的域名:</p>\n<p><img src="http://img.xheldon.com/img/hosts.png" alt="hosts" title="hosts"></p>\n<p><img src="http://img.xheldon.com/img/LocalServer.png" alt="LoccalServer" title="LoccalHosts"></p>\n<p><img src="http://img.xheldon.com/img/VPSServer.png" alt="VPSServer" title="VPSServer"></p>\n<p>首先是在 <code>VPS</code> 服务器上启动一个 <code>express</code> 服务, 不设置任何东西, 只是简单的返回 <code>header</code>:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'express\'</span>);\n<span class="hljs-keyword">var</span> app = express();\n\napp.get(<span class="hljs-string">\'/\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>)</span>{\n  res.send(req.headers);\n});\n\napp.listen(<span class="hljs-number">9091</span>);\n</code></pre>\n<p><code>a.com</code> 的 <code>Server</code> 端基本一样, 只是加了个静态页为了发送 <code>ajax</code>:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'express\'</span>);\n<span class="hljs-keyword">var</span> app = express();\n<span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>);\napp.get(<span class="hljs-string">\'/\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>{\n  res.sendFile(path.join(__dirname, <span class="hljs-string">\'index.html\'</span>));\n});\napp.listen(<span class="hljs-number">9090</span>);\n</code></pre>\n<p><code>index.html</code> 内容:</p>\n<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>a.com<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"button"</span>&gt;</span>点我发请求, 打开控制台查看信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'button\'</span>);\n\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xhrSend</span>(<span class="hljs-params">e</span>)</span>{\n    e.preventDefault();\n    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();\n    xhr.open(<span class="hljs-string">\'GET\'</span>, <span class="hljs-string">\'http://www.b.com:9091\'</span>, <span class="hljs-literal">true</span>);\n    xhr.send();\n  }\n\n  button.addEventListener(<span class="hljs-string">\'click\'</span>, xhrSend);\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<p>因为服务端没有设置 <code>Access-Control-Allow-Origin</code>, 因此报错: </p>\n<p><img src="http://img.xheldon.com/img/VPSServerError.png" alt="VPSServerError" title="VPSServerError"></p>\n<p>接下来在 <code>b.com</code> 的服务端加上允许来自 <code>a.com</code> 的 <code>ajax</code>(需要精确到端口):</p>\n<pre><code class="hljs javascript">app.get(<span class="hljs-string">\'/\'</span>, <span class="hljs-keyword">function</span>(req, res, <span class="hljs-keyword">next</span>){\n  res.set({\n    <span class="hljs-string">\'Access-Control-Allow-Origin\'</span>: <span class="hljs-string">\'http://www.a.com:9090\'</span>\n  });\n  res.send(req.headers);\n});\n</code></pre>\n<p>再次发起请求:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError1.png" alt="VPSServerError1" title="VPSServerError1"></p>\n<p><img src="http://img.xheldon.com/img/VPSServerError1.1.png" alt="VPSServerError1.1" title="VPSServerError1.1"></p>\n<p>控制台没有报错, 而且状态码为 <code>200</code> 说明 <code>b.com</code> 已经允许来自 <code>a.com:9090</code> 的请求.</p>\n<h2 id="-2-cookie">小目标-2: 本地服务接收前端的 <code>cookie</code></h2>\n<p>接下来我们先在本地测试下 <code>a.com</code> 后端能否获取到来自前端的 <code>cookie</code>:</p>\n<p>测试方法很简单, 随便加点 <code>cookie</code> 在 <code>js</code> 中即可:</p>\n<pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">\'domain=a.com;\'</span>;\n<span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">\'name=xheldon\'</span>;\n<span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">\'lover=xiaodan\'</span>;\n</code></pre>\n<p><img src="http://img.xheldon.com/img/LocalServer1.png" alt="LocalServer1" title="LocalServer1"></p>\n<p>在本地控制台的 <code>Application</code> 选项卡可以看到已经有了 <code>cookie</code>, 再看看后端输出:</p>\n<p><img src="http://img.xheldon.com/img/LocalServer2.png" alt="LocalServer2" title="LocalServer2"></p>\n<p>OK 没毛病, 访问 <code>www.a.com:9090</code> 的时候确实带上了 <code>cookie</code>, 意料之中.</p>\n<h2 id="-3-a-com-cookie-b-com">小目标-3: 把 <code>a.com</code> 的 <code>cookie</code> 发送到 <code>b.com</code></h2>\n<p>这个时候 <code>a.com</code> 的页面是有 <code>cookie</code> 的, 因此我们再次点击按钮, 看 <code>ajax</code> 请求能否把 <code>cookie</code> 传递给 <code>b.com</code>:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError1.2.png" alt="VPSServerError1.2" title="VPSServerError1.2"></p>\n<p>和没有加 <code>cookie</code> 一样, 并没有获取到来自 <code>a.com</code> 的 <code>cookie</code>, 这当然是因为安全限制, 也是意料之中.</p>\n<h2 id="-">额外定一个小目标: 非简单请求</h2>\n<p>此处插播一个关于简单请求的测试, 在 <code>xhr</code> 中新增一个 <code>header</code>, 之后再发请求: </p>\n<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xhrSend</span><span class="hljs-params">(e)</span></span>{\n  e.preventDefault();\n  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();\n  xhr.open(<span class="hljs-string">\'GET\'</span>, <span class="hljs-string">\'http://www.b.com:9091\'</span>, <span class="hljs-literal">true</span>);\n  xhr.setRequestHeader(<span class="hljs-string">\'xiaodan\'</span>, <span class="hljs-string">\'xheldon\'</span>);\n    xhr.send();\n  }\n</code></pre>\n<p>因为这次是在加了 <code>Access-Control-Allow-Origin</code> 之后的操作, 因此这次浏览器报了个不一样的错误:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.1.png" alt="VPSServerError2.1" title="VPSServerError2.1"></p>\n<p>注意到还是因为 <code>Access-Control-Allow-Origin</code> 的错误, 但是这次是因为前端设置了一个自定义的 <code>header</code>, 因此是一个非简单请求, 对于非简单请求会先发一个预检请求(<code>prelight</code>), 请求类型是 <code>OPTIONS</code>, 可以查看 <a href="http://harttle.com/2016/12/30/cors-preflight.html" target="_blank">这篇文章</a> 了解更多. 预检请求目的是嘘寒问暖 <code>b.com</code> 的服务器, 是否接受这个 <code>xiaodan</code> 的 <code>header</code>, 后端在返回的 <code>header</code> <code>Access-Control-Alow-Headers</code> 中, 没有这个叫做 <code>xiaodan</code> 的值, 因此报错.</p>\n<p>那接下来我们把 <code>b.com</code> 返回的内容加上 相应的 <code>header</code>:</p>\n<pre><code class="hljs javascript">app.get(<span class="hljs-string">\'/\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(req.headers);\n  res.set({\n    <span class="hljs-string">\'Access-Control-Allow-Origin\'</span>: <span class="hljs-string">\'http://www.a.com:9090\'</span>,\n    <span class="hljs-string">\'Access-Control-Allow-Headers\'</span>: <span class="hljs-string">\'xiaodan\'</span>\n  });\n  res.send(req.headers);\n});\n</code></pre>\n<p>再次发起请求看看:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.1.png" alt="VPSServerError2.1" title="VPSServerError2.1"></p>\n<p>居然是一样的报错结果, 虽然响应了 <code>200</code>, 但是服务端没有返回相应的 <code>Access-Control-Allow-Headers</code>, 返回结果被浏览器拒绝了(注意不是被服务器拒绝, 服务器是返回了 <code>200</code> 的).</p>\n<p>排查了一下发现, 问题出在这个非简单请求上面, 我把 <code>b.com</code> 函数稍微修改下:</p>\n<pre><code class="hljs javascript">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span></span>{\n  res.set({\n    <span class="hljs-string">\'Access-Control-Allow-Origin\'</span>: <span class="hljs-string">\'http://www.a.com:9090\'</span>,\n    <span class="hljs-string">\'Access-Control-Allow-Headers\'</span>: <span class="hljs-string">\'xiaodan\'</span>\n  });\n  <span class="hljs-built_in">next</span>();\n});\n\napp.get(<span class="hljs-string">\'/\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span></span>{\n  console.<span class="hljs-built_in">log</span>(req.headers);\n  res.send(req.headers);\n});\n</code></pre>\n<p>服务端:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.2.png" alt="VPSServerError2.2" title="VPSServerError2.2"></p>\n<p>客户端:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.3.png" alt="VPSServerError2.3" title="VPSServerError2.3"></p>\n<p>分析原因在于(待求证, 回头翻翻 <code>HTTP</code> 权威指南再说), 非简单请求的 <code>prelight</code> 请求, 不会发起实际请求, 而是先发送一个预检请求, 来测试服务器是否支持某个非简单 <code>header</code> 字段, 也就是说, 带有非简单头部的请求不会走到 <code>app.get(&#39;/&#39;)</code> 里面. 同时可以在 <code>b.com</code> 的服务器看到, 因为 <code>console.log(req.headers)</code> 是写在 <code>app.get(&#39;/&#39;)</code> 里面的, 刚刚的请求 <code>b.com</code> 服务器并没有输出任何东西, 因此也印证了这一点. <code>这一设计旨在确保服务器对 CORS 标准知情，以保护不支持 CORS 的旧服务器</code>. </p>\n<h2 id="-4-a-com-cookie-b-com">小目标-4: 把 <code>a.com</code>  域下的 <code>cookie</code> 发送到 <code>b.com</code></h2>\n<p>OK, 插播结束, 我们来测试下在客户端, 也即 <code>a.com</code> 下发起的 <code>xhr</code> 请求的页面设置 <code>withCredentials = true</code> (只列出 <code>xhrSend</code> 部分)能否将 <code>a.com</code> 的 <code>cookie</code> 发送到 <code>b.com</code>(这里简单请求和非简单请求是一样的结果, 为了方便查看差异我把 <code>xhr</code> 设置的 <code>header</code> 去掉了):</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// 设置允许 cookie</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xhrSend</span><span class="hljs-params">(e)</span></span>{\n  e.preventDefault();\n  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();\n  xhr.open(<span class="hljs-string">\'GET\'</span>, <span class="hljs-string">\'http://www.b.com/\'</span>, <span class="hljs-literal">true</span>);\n  xhr.withCredentials = <span class="hljs-literal">true</span>;\n  xhr.send();\n}\n</code></pre>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.4.png" alt="VPSServerError2.4" title="VPSServerError2.4"></p>\n<p>这次错误提醒变化, 变成服务端没有设置 <code>Access-Control-Allow-Credentials</code> 为 <code>true</code> 了, 这个 <code>header</code> 是来设置允许请求携带 <code>cookie</code> 的, 因此设置一下:</p>\n<pre><code class="hljs javascript">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req,res, next)</span></span>{\n  res.set({\n    <span class="hljs-string">\'Access-Control-Allow-Origin\'</span>:<span class="hljs-string">\'http://www.a.com:9090\'</span>,\n    <span class="hljs-string">\'Access-Control-Allow-Headers\'</span>: <span class="hljs-string">\'xiaodan\'</span>,\n    <span class="hljs-string">\'Access-Control-Allow-Credentials\'</span>: <span class="hljs-literal">true</span>\n  });\n  <span class="hljs-built_in">next</span>();\n});\n\napp.get(<span class="hljs-string">\'/\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span></span>{\n  console.<span class="hljs-built_in">log</span>(req.headers);\n  res.send(req.headers);\n});\n</code></pre>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.5.png" alt="VPSServerError2.5" title="VPSServerError2.5"></p>\n<p>仍然没有, 看下 <code>Chrome</code> 的 <code>cookie</code>:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.6.png" alt="VPSServerError2.6" title="VPSServerError2.6"></p>\n<p>确实是设置了 <code>cookie</code> 啊, 什么情况? 不服, 想着 <code>req.headers</code> 是 <code>express</code> 格式化之后的, 看看原始 <code>headers</code> <code>rawHeaders</code>:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.7.png" alt="VPSServerError2.7" title="VPSServerError2.7"></p>\n<p>还是没看到, <code>cookie</code> 被狗吃了吗?</p>\n<blockquote>\n<p>都没有, 她说将来会找到, 时间,时间会给我答案 ------我的滑板鞋</p>\n</blockquote>\n<p>OK, 找不到问题的时候就吃个冰淇淋吧. 下楼买了个香菜味的雀巢冰激凌(吃不起哈根达斯), 然后在上楼的时候灵光一闪, 好像我们这个属于是第三方 <code>cookie</code>, 会不会是我禁止浏览器追踪导致的呢? 于是吃完冰激凌我在 <code>chrome</code> 的设置中, 把 <code>随浏览流量一起发送&quot;不跟踪&quot;请求</code> 的钩钩给去掉了:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.8.png" alt="VPSServerError2.8" title="VPSServerError2.8"></p>\n<p>对了, 这次我把 <code>req.headers</code> 放到了 <code>app.use</code> 里面以防万一(其实不会有什么万一)：</p>\n<pre><code class="hljs javascript">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req,res, next)</span></span>{\n  console.<span class="hljs-built_in">log</span>(req.headers);\n  res.set({\n    <span class="hljs-string">\'Access-Control-Allow-Origin\'</span>:<span class="hljs-string">\'http://www.a.com:9090\'</span>,\n    <span class="hljs-string">\'Access-Control-Allow-Headers\'</span>: <span class="hljs-string">\'xiaodan\'</span>,\n    <span class="hljs-string">\'Access-Control-Allow-Credentials\'</span>: <span class="hljs-literal">true</span>\n  });\n  <span class="hljs-built_in">next</span>();\n});\n\napp.get(<span class="hljs-string">\'/\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span></span>{\n  res.send(req.headers);\n});\n</code></pre>\n<p>再次点击按钮发送请求, 然后查看 <code>chrome</code> 控制台和 <code>b.com</code> 的服务器输出:</p>\n<p>因为有非简单头部, 因此和之前一样, 显示的是两个请求:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.9.png" alt="VPSServerError2.9" title="VPSServerError2.9"></p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.9.1.png" alt="VPSServerError2.9.1" title="VPSServerError2.9.1"></p>\n<p>服务器也没有接收到, 说明和这个 <code>Chrome</code> 设置无关, 因此为了控制变量 <code>不跟踪</code> 和之前一样, 我把它又钩上了, 服务器端(只放了 <code>GET</code> 请求):</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError2.9.2.png" alt="VPSServerError2.9.2" title="VPSServerError2.9.2"></p>\n<p>还是没有 <code>Cookie</code> 字段, 为什么呢? </p>\n<p>我又想起了文章开头的那句话: &#39;注意, 设置了 <code>withCredentials = true</code> 之后, 携带的 <code>cookie</code> 是目标域的 <code>cookie</code>&#39;. 难道我在 <code>a.com</code> 点击按钮发送请求到 <code>b.com</code>, 发送的是 <code>b.com</code> 设置的 <code>cookie</code> 吗? </p>\n<p>于是我先把 <code>b.com</code> 服务器上也新建一个 <code>index.html</code>, 里面随便加点 <code>cookie</code>:</p>\n<p><code>b.com</code> 的服务器代码:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'express\'</span>);\n<span class="hljs-keyword">var</span> app = express();\n<span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>);\napp.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res, next</span>)</span>{\n<span class="hljs-built_in">console</span>.log(req.headers);\nres.set({\n  <span class="hljs-string">\'Access-Control-Allow-Origin\'</span>:<span class="hljs-string">\'http://www.a.com:9090\'</span>,\n  <span class="hljs-string">\'Access-Control-Allow-Headers\'</span>: <span class="hljs-string">\'xiaodan\'</span>,\n  <span class="hljs-string">\'Access-Control-Allow-Credentials\'</span>: <span class="hljs-literal">true</span>\n});\nnext();\n});\n\napp.get(<span class="hljs-string">\'/\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>)</span>{\n  res.sendFile(path.join(__dirname, <span class="hljs-string">\'index.html\'</span>));\n});\n\napp.listen(<span class="hljs-number">9091</span>);\n</code></pre>\n<p>b.com 的 index.html 代码:</p>\n<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>a.com<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>open Application inspector to check whether the cookie is be setting<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">\n    <span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">\'yes=you_cant_believe_i_from_b.com\'</span>\n    <span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">\'from=this_is_from_b.com\'</span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<p>OK, 我们首先访问 <code>b.com</code>:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError4.png" alt="VPSServerError4" title="VPSServerError4"></p>\n<p>没毛病, 正常返回网页, 正常设置 <code>cookie</code>, 接下来我们在 <code>a.com</code> 下, 点击按钮发送请求:</p>\n<p><img src="http://img.xheldon.com/img/VPSServerError4.1.png" alt="VPSServerError4.1" title="VPSServerError4.1"></p>\n<p>可以看到在 <code>a.com</code> 发起的 <code>ajax</code> 请求, 带上了 <code>b.com</code> 的 <code>cookie</code>.</p>\n<p>文章开始的那句话得到了证实.</p>\n<h2 id="-5-a-com-javascript-b-com-cookie-">小目标-5: <code>a.com</code> 的 <code>JavaScript</code> 获取 <code>b.com</code> 的 <code>cookie</code>:</h2>\n<p>既然能在 <code>a.com</code> 发送 <code>b.com</code> 的 <code>cookie</code>, 那么前端能不能获取到 <code>b.com</code> 的 <code>cookie</code> 呢?</p>\n<p>看了下文档, <code>ajax</code> 有 <code>getAllResponseHeaders()</code> 和 <code>getResponseHeader()</code>两个接口, 服务端有 <code>Access-Control-Expose-Header</code>, 于是我测试了下(我就是要分开输出, 怎样?).</p>\n<p>先从简单的来, 首先是调用 <code>xhr</code> 的 <code>getAllResponseHeaders()</code> 接口:</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// 设置允许 cookie</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xhrSend</span>(<span class="hljs-params">e</span>)</span>{\n  e.preventDefault();\n  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();\n  xhr.open(<span class="hljs-string">\'GET\'</span>, <span class="hljs-string">\'http://www.b.com/\'</span>, <span class="hljs-literal">true</span>);\n  xhr.withCredentials = <span class="hljs-literal">true</span>;\n  xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === <span class="hljs-number">200</span>){\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'AllRes:\'</span>, <span class="hljs-keyword">this</span>.getAllResponseHeaders())\n    }\n  };\n  xhr.send();\n}\n</code></pre>\n<p><img src="http://img.xheldon.com/img/LocalServer3.png" alt="LocalServer3" title="LocalServer3"></p>\n<p>发现并没有出现 <code>header</code> 的 <code>Cookie</code> 字段, 意料之中, 想着万一 <code>getAllResponseHeaders()</code> 遍历 <code>header</code> 的没有 <code>Cookie</code> 是因为其被设置成 <code>enumerable: false</code> 了呢? 于是我又尝试了 <code>getResponseHeader()</code>:</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// 设置允许 cookie</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xhrSend</span>(<span class="hljs-params">e</span>)</span>{\n  e.preventDefault();\n  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();\n  xhr.open(<span class="hljs-string">\'GET\'</span>, <span class="hljs-string">\'http://www.b.com/\'</span>, <span class="hljs-literal">true</span>);\n  xhr.withCredentials = <span class="hljs-literal">true</span>;\n  xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === <span class="hljs-number">200</span>){\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Res:\'</span>, <span class="hljs-keyword">this</span>.getResponseHeader(<span class="hljs-string">\'Cookie\'</span>))\n    }\n  };\n  xhr.send();\n}\n</code></pre>\n<p><img src="http://img.xheldon.com/img/LocalServer3.1.png" alt="LocalServer3.1" title="LocalServer3.1"></p>\n<p>还是意料之中, 因为服务端没有设置暴露出来的 <code>header</code> 内容, 于是我在 <code>b.com</code> 设置了 <code>Access-Control-Expose-Header</code>:</p>\n<pre><code class="hljs javascript">res.set({\n  <span class="hljs-symbol">\'Access</span>-Control-Allow-Origin<span class="hljs-string">\':\'</span>http:<span class="hljs-comment">//www.a.com:9090\',</span>\n  <span class="hljs-symbol">\'Access</span>-Control-Allow-Headers\': <span class="hljs-symbol">\'xiaodan</span>\',\n  <span class="hljs-symbol">\'Access</span>-Control-Allow-Credentials\': <span class="hljs-literal">true</span>,\n  <span class="hljs-symbol">\'Access</span>-Control-Expose-Headers\': <span class="hljs-symbol">\'Cookie</span>\'\n});\n</code></pre>\n<p>然后重新执行 <code>getResponseHeader(&#39;Cookie&#39;)</code> 和 <code>getAllResponseHeaders()</code></p>\n<p><img src="http://img.xheldon.com/img/LocalServer3.2.png" alt="LocalServer3.2" title="LocalServer3.2"></p>\n<p>没有错误了, 但是还是无法获取到 <code>b.com</code> 的 <code>cookie</code>, 即使 <code>b.com</code> 服务端都同意了也不行.</p>\n<p><img src="http://img.xheldon.com/img/angry.jpg" alt="angry" title="angry"></p>\n<p>查找资料得知, 这个 <code>Access-Control-Expose-Header</code> 只能设置为自定义的 <code>header</code> 来被前端获得. 但是这个没什么意义啊, 因为这个自定义的 <code>header</code> 就是我前端设置的, 唯一的作用就是 后端修改/新建自定义的 <code>header</code> 之后, 前端来获取. 下面我在后端设置一个 <code>header</code>, 让前端来获取:</p>\n<p><code>b.com</code> 的 <code>server</code>:</p>\n<pre><code class="hljs javascript">res.set({\n  <span class="hljs-symbol">\'Access</span>-Control-Allow-Origin<span class="hljs-string">\':\'</span>http:<span class="hljs-comment">//www.a.com:9090\',</span>\n  <span class="hljs-symbol">\'Access</span>-Control-Allow-Headers\': <span class="hljs-symbol">\'xiaodan</span>\',\n  <span class="hljs-symbol">\'Access</span>-Control-Allow-Credentials\': <span class="hljs-literal">true</span>,\n  <span class="hljs-symbol">\'Access</span>-Control-Expose-Headers\': <span class="hljs-symbol">\'Xheldon</span>\',\n  <span class="hljs-symbol">\'Xheldon</span>\': <span class="hljs-symbol">\'MyNameIsXheldon</span>\'\n});\n</code></pre>\n<p><code>a.com</code> 的 <code>index.html</code>:</p>\n<pre><code class="hljs javascript">xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === <span class="hljs-number">200</span>){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Res:\'</span>, <span class="hljs-keyword">this</span>.getResponseHeader(<span class="hljs-string">\'Xheldon\'</span>));\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'AllRes:\'</span>, <span class="hljs-keyword">this</span>.getAllResponseHeaders());\n  }\n};\n</code></pre>\n<p><img src="http://img.xheldon.com/img/LocalServer3.3.png" alt="LocalServer3.3" title="LocalServer3.3"></p>\n<p>就是这样.</p>\n<p>所以这个小目标是实现不了了, 但是 <code>SO</code> 社区给出了一些解决办法, 比如 使用第三方服务/后端做转发 等, 毕竟规定是死的, 人是活的, 就像 <code>jsonp</code> 一样, 是吧.</p>\n<h2 id="-">联想</h2>\n<p>有人说培训几个月零基础就可以精通某种语言, 我觉得是天方夜谭. 因为在没有计算机基础知识的情况下, 在搞不清二进制/编译原理/计算机原理/操作系统原理/网络基础/通讯协议的是什么概念的情况下能写出代码, 只能说明你照葫芦画瓢的学习能力强, 你知道这么写是这么个效, 但是你不知道为什么这么写就会出现这么个效果. </p>\n<p>因此在跟计算机打交道的时候, 知识面是越广越好, 知识深度是越深越好. 这不, 我在了解 CORS 的时候, 想起了之前接触过的 AUTH.</p>\n<p>有个叫 <code>AUTH2.0</code> 的东西, 那它跟 <code>CORS</code> 有什么关系呢? 我也不知道, 在此声明, jiang来对以下内容出问题了我不负泽, 民不民白?:</p>\n<p><img src="http://img.xheldon.com/img/naive.jpg" alt="Naive" title="Naive"></p>\n<p><code>CORS</code>, 可以让访问过 <code>B</code> 站的用户, 从 <code>A</code> 站发起请求的时候, 携带 <code>B</code> 站的 <code>cookie</code>. 步骤是:</p>\n<ol>\n<li>用户访问过 <code>B</code> 站.</li>\n<li>用户访问 <code>A</code> 站, 在 <code>A</code> 站发起请求到 <code>B</code> 站.</li>\n<li><code>B</code> 站验证来自 <code>A</code> 站的请求中的来自 <code>B</code> 站的 <code>cookie</code>, 没毛病, 返回 <code>B</code> 站的数据.</li>\n</ol>\n<p><code>AUTH</code>, 可以让用户在 <code>A</code> 网站访问 <code>B</code> 网站的资源. 前提是需要用户授权, 步骤是:</p>\n<ol>\n<li>在 <code>A</code> 网站发起请求.</li>\n<li>步骤1跳转到 <code>B</code> 站, 确认授权, 再跳转回 <code>A</code> 网站.</li>\n<li>此时 <code>A</code> 网站拿到 <code>tooken(令牌)</code> 就能访问用户在 <code>B</code> 网站的资源了.</li>\n</ol>\n<p>有木有很像? </p>\n<p><code>CORS</code> 的第一步对应 <code>AUTH</code> 的第二步. <code>AUTH</code> 的第二步相当于 <code>CORS</code> 的第一步的可以认为是在 <code>B</code> 网站的服务端加上了 <code>Access-Control-Allow-Credentials</code>, 这样就代表完成授权.</p>\n<p>可以认为 <code>CORS</code> 携带 <code>cookie</code> 是简化版的 <code>AUTH</code>.</p>\n<p>以下摘自 <code>RFC 6749</code></p>\n<p><img src="http://img.xheldon.com/img/AUTH.png" alt="AUTH" title="AUTH"></p>\n<h2 id="-">后记</h2>\n<p>为什么说, 第三方广告 <code>cookie</code> 会泄露隐私呢? 这是因为广告放在一个 <code>A</code> 网站上, 广告主就知道这个广告投放到了 <code>A</code> 网站(通过广告投放的 <code>id/key</code> 之类的 <code>identity</code> 来标识 和付费), 于是广告主在这个广告上设置一个 <code>cookie</code>, 这个广告来自广告 <code>B</code> 的域名, 因此设置的 <code>cookie</code> 当然是来自 <code>B</code> 的 <code>cookie</code>, 每次 <code>A</code> 网站加载这个广告的时候, 肯定是要执行一段 <code>js</code> 的, 在这个 <code>js</code> 中, 设置了允许 <code>A</code> 站发送 <code>cookie</code>, 而同时 <code>B</code> 站也允许来自 <code>A</code> 站的 <code>cookie</code> 携带 <code>B</code> 站的 <code>cookie</code> 发送过来, 因此就什么都知道了.</p>\n<p>`Google AD Impl:</p>\n<p><img src="http://img.xheldon.com/img/googleWithCredentials.png" alt="googleWithCredientials" title="googleWithCredientials"></p>\n<p><img src="http://img.xheldon.com/img/googleWithCredentials2.png" alt="googleWithCredientials2" title="googleWithCredientials2"></p>\n<h2 id="-">注意</h2>\n<ol>\n<li><p>上述修改涉及到服务端的修改, 均需要重启服务. 因为在 <code>VPS</code> 上重启服务不太方便, 而且时间久了连接会断开, 因此最好的办法是在 <code>VPS</code> 上放置文章中的 <code>a.com</code> (主要用来修改 <code>index.html</code> 的), 而在本地放置文章中的 <code>b.com</code> 的内容(主要用来修改 <code>index.js</code> 的).</p>\n</li>\n<li><p>远程链接保持不断开, 最简单的办法是将其后台(前提是保持链接, 不然断开链接之后, 请求过来进行 <code>I/O</code> 操作, 仍然会被断开). 可以运行 <code>node index.js &amp;</code>, 或者在已经运行 <code>node index.js</code> 的时候按 <code>ctrl+z</code>, 将其冻结在后台, 然后执行 <code>bg</code> 命令将最近一个后台的任务激活. <code>jobs</code> 命令可以查看在当前任务列表. 如果退出了当前 <code>session</code>, 之后重新连接的话, 任务仍然在运行, 但是 <code>jobs</code> 已经看不到该任务了, 因此需要 <code>ps -A</code> 列出所有进程, 然后 <code>kill ID</code> 终止 <code>node</code> 所在的那个进程, 重新运行即可.</p>\n</li>\n<li><p>完成小目标期间出错的时候我怀疑是没有把自定义字段设置为以 <code>X-</code> 开头才报错的, 看了下标准发现并没有以 <code>X-</code> 的规定, 维基和SO 上只是推荐自定义 <code>Header</code> 以 <code>X-</code> 开头而已.</p>\n</li>\n<li><p>设置了 <code>withCredentials = true</code> 之后, 服务端的 <code>Access-Control-Allow-Origin</code> 就不能再设置为 <code>wildcard</code> <code>*</code> 了</p>\n</li>\n</ol>\n'},304:function(s,e){s.exports='<h1 id="-">环境配置/常用软件汇总</h1>\n<p>date:   2016-07-08 20:33:34 +0800</p>\n<h3 id="-think-">分类: [Think]</h3>\n<hr>\n<p>每次拿到一个新电脑, 总是手忙脚乱的安装一堆的工具, 有时候还总是忘记装一些软件, 等到用到的时候才想起来下载, 而刚进入工作的时候上司交代的第一件事往往就是&quot;刚来先熟悉一下环境, 配置一下自己的电脑&quot;. 因此这篇文章记录下我常用的软件, 以备不时之需.</p>\n<p><code>QQ/OneNote微信/网易云音乐</code>可以直接在 <code>Mac App</code> 的热门免费软件中下载.</p>\n<p>1.<code>Shadowsocks</code> 放在百度网盘, 为了下一步下载 <code>Chrome</code> </p>\n<p>2.迅雷 使用 <code>Safari</code> 自带的下载工具下载后面的软件, 巨慢.</p>\n<p>3.<code>Chrome</code></p>\n<p>4.<code>Webstrom</code>  激活服务器: <code>http://idea.iteblog.com/key.php</code></p>\n<p>5.<code>Sublime3</code></p>\n<ol>\n<li><p>激活 <code>key</code>:</p>\n<p> —– BEGIN LICENSE —–\nNicolas Hennion\nSingle User License\nEA7E-866075\n8A01AA83 1D668D24 4484AEBC 3B04512C\n827B0DE5 69E9B07A A39ACCC0 F95F5410\n729D5639 4C37CECB B2522FB3 8D37FDC1\n72899363 BBA441AC A5F47F08 6CD3B3FE\nCEFB3783 B2E1BA96 71AAF7B4 AFB61B1D\n0CC513E7 52FF2333 9F726D2C CDE53B4A\n810C0D4F E1F419A3 CDA0832B 8440565A\n35BF00F6 4CA9F869 ED10E245 469C233E\n—— END LICENSE ——</p>\n</li>\n<li><p>安装边栏增强工具 <code>SideBarEnhancements</code></p>\n<p> command+shift+p 输入 install 回车, 之后重复按 command+shift+p 输入 SideBarEn 回车</p>\n</li>\n<li><p>安装 <code>Sublime</code> 插件 <code>Terminal</code>(在 <code>Sublime</code> 中打开 <code>Terminal</code>)</p>\n<p> command+shift+p 输入 Terminal 回车.</p>\n<blockquote>\n<p>设置 &quot;terminal&quot;: &quot;iTerm2-v3.sh&quot; 使用 iTerm2 打开当前文件</p>\n</blockquote>\n</li>\n</ol>\n<p>6.<code>iTerm2</code></p>\n<pre><code><span class="hljs-attribute">ssh</span> -p 端口 用户名<span class="hljs-variable">@ip</span>\n</code></pre><p>7.<code>Node</code></p>\n<p>8.<code>Oh My Zsh</code></p>\n<pre><code>sh -c <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span>\n</code></pre><p>9.<code>git</code></p>\n<pre><code>公钥配置: ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">"your_email@example.com"</span>\n配置用户: git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">"Xheldon"</span>\n配置邮箱: git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">"c1006044256@gmail.com"</span>\n</code></pre><p>10.<code>sougou</code> 输入法</p>\n<p>11.<code>charles</code> 抓包工具, 下载补丁替换 charles.jar 即可破解.</p>\n<p>12.<code>XCode</code> 一些东西依赖其 <code>cli</code></p>\n<p>13.安装 <code>homebrew</code></p>\n<pre><code><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/ruby -e "$(curl -fsSL https:/</span><span class="hljs-regexp">/raw.githubusercontent.com/</span>Homebrew<span class="hljs-regexp">/install/m</span>aster<span class="hljs-regexp">/install)"</span>\n</code></pre><p>14.本地配置 <code>Jeklly</code> 环境</p>\n<blockquote>\n<p><code>ruby</code> 需要2.1或更高版本.</p>\n</blockquote>\n<ol>\n<li><p>安装 <code>rvm</code>(稍久, 机器会发热)</p>\n<p> \\curl -sSL <a href="https://get.rvm.io">https://get.rvm.io</a> | bash -s stable --ruby</p>\n<blockquote>\n<p>之后关闭所有 <code>shell</code> 继续下面的步骤, 或者运行 <code>source /Users/Xheldon/.rvm/scripts/rvm</code> 之后再继续下面的步骤.</p>\n</blockquote>\n</li>\n<li><p>查看已知 <code>ruby</code> 版本</p>\n<p> rvm list known</p>\n</li>\n<li><p>安装 <code>ruby2.2.0</code></p>\n<p> rvm install 2.2.0</p>\n<blockquote>\n<p>期间需要 mkdir -p /tec/openssl 的权限, 因此需要输入密码.</p>\n</blockquote>\n</li>\n<li><p>更换 <code>gem source</code>:</p>\n<p> gem sources -l //查看当前源\n gem source --remote <a href="https://rubygems.org/">https://rubygems.org/</a> //移除当前源\n gem source -a <a href="https://gems.ruby-china.org">https://gems.ruby-china.org</a>  //新增源</p>\n</li>\n<li><p>安装 <code>bundler</code></p>\n<p> gem install bundler</p>\n</li>\n<li><p>安装 <code>jekyll</code> 和其他依赖.</p>\n<blockquote>\n<p>cd 到项目根目录(假设你已经 <code>clone</code> 了 <code>jekyll</code> 博客)执行:</p>\n</blockquote>\n<p> bundle install</p>\n<blockquote>\n<p>完成后即可执行 <code>bundle exec jekyll serve</code> 查看本地起的 <code>jekyll</code>(如果提示找不到 bundle 命令, 重新执行第五六步即可)</p>\n</blockquote>\n</li>\n</ol>\n<h2 id="-">其他</h2>\n<p>可能需要的操作:</p>\n<p>1.允许任何安装来源:</p>\n<pre><code>sudo spctl <span class="hljs-comment">--master-disable</span>\n</code></pre>'},305:function(s,e){s.exports='<h1 id="-">新博客地址说明</h1>\n<p>date:   2099-01-01 22:13:35 +0800</p>\n<h3 id="-others-">分类: [Others]</h3>\n<hr>\n<p>博客迁移至此，丢了很多之前写的东西，xml转json不好用，只能手动复制粘贴恢复了。</p>\n<p>目前只恢复了几篇，从搜索引擎过来的朋友，请见谅。</p>\n'},306:function(s,e){s.exports='<h1 id="-">关于</h1>\n<hr>\n<p>我叫 Xheldon 会计学专业（专业调剂我表示很无奈）, 但是经常去蹭软件学院的课, 因此一些算法基础和数据结构之类的计算机基础课程略懂. </p>\n<p>我喜欢互联网, 喜欢写代码, 因此大学四年我学习了前端的一些知识如HTML、CSS、Photoshop、Javascript、jQuery、 Bootstrap等, 主攻Javascript. 在校初步尝试了Grunt、NodeJS、AngularJS的用法. 发现如果要深入了解一门语言必须知道这门语言的Good Parts And Bad Parts以和其他语言作对比, 因此为了加深理解, 我还初步学习了解了C、VB、C#、Java、Android的运行原理和语法. </p>\n<p>在校期间, 积极参加各种计算机/前端相关社团, 加入了校网社团和校CERT社团, 社团中的前辈们在得知我是非计算机专业的同学之后, 热心的帮助我学习了很多计算机领域的基本概念和常识, 对我的自学之路帮助很大, 我也曾作为前端人员获得校软件设计大赛团队三等奖, 在此表示感谢.</p>\n<p>在不断的学习过程中发现自己对计算机的深层原理如内存分配/二进制/网络通信协议/编译原理/CPU工作原理/数据传输等计算机底层基础知识有很多不解的地方, 因此在试图利用网易云课堂开设的《大学计算机专业》课程体系对自身的计算机科学知识进行补充. </p>\n<p>目前主要研究方向是Javascript, 职业方向是前端系统架构师. </p>\n<p>曾经就职于慧科教育旗下的极客标签（北京）团队从事前端开发工作, 有幸参与了网站从jQuery开发模式升级到以Sea.js为基础架构, 结合Grunt打包工具的开发模式的开发工作. </p>\n<p>也曾经就职于什么值得买（北京）公司(人称张大妈)技术中心前端团队, 从事前端开发工作, 有幸参与了PC端从jQuery开发模式逐步升级到以Webpack为基础, 以Gulp为打包工具的模块化开发的升级过程. 也参与了公司移动端(app 内嵌) Vue+webpack 的基础开发架构搭建. </p>\n<p>目前就职于美团网.</p>\n<p>特别声明: 本博客观点只代表自己, 不代表公司, 请勿上纲上线.</p>\n<p>我的微信订阅号名称：漫漫前端路\n微信订阅号：CoderXheldon\n（基本没有维护, 占着号先 0_0）</p>\n<p>联系我请发邮箱c1006044256[at]gmail.com</p>\n'},307:function(s,e,n){var a={"./2015-06-05-in-the-ganjiang-river.md":290,"./2015-07-20-how-to-use-rz-sz-on-mac.md":291,"./2015-10-01-how-i-think-people-privacy.md":292,"./2015-10-30-how-to-work.md":293,"./2015-12-21-weibo-jssdk.md":294,"./2016-03-04-promise-antipattern.md":295,"./2016-04-21-git-command.md":296,"./2016-04-30-vue-simple-use.md":297,"./2016-05-02-webpack-details-one.md":298,"./2016-05-23-github-pages-config.md":299,"./2016-06-01-vue-learning-summary.md":300,"./2016-06-12-three-ways-to-make-a-vue-SPA-use-router.md":301,"./2016-07-03-some-complain.md":302,"./2016-07-07-research-CORS.md":303,"./2016-07-08-softerware-i-use-usually.md":304,"./2099-01-01-blog-reference.md":305,"./about.md":306,"./post-list":20,"./post-list.js":20};function c(s){return n(o(s))}function o(s){var e=a[s];if(!(e+1))throw new Error("Cannot find module '"+s+"'.");return e}c.keys=function s(){return Object.keys(a)},c.resolve=o,(s.exports=c).id=307}});