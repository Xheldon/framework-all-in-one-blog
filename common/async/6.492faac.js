webpackJsonp([6],{301:function(e,n){e.exports='<h1 id="vue-">Vue 实现路由的三种方式</h1>\n<p>date:   2016-06-12 22:13:35 +0800</p>\n<h3 id="-vue-framework-">分类: [Vue, Framework]</h3>\n<hr>\n<p>Vue 学习总结基本告一个段落, 接下来会补充一些其他的碎片知识, 今天说下 Vue Router 的三种实现方式.</p>\n<p><a href="https://github.com/Xheldon/Framework/tree/master/VueSPA" target="_blank">查看项目完整代码</a>(本项目含有其他 Vue 测试代码如 Vue Plugin 等)</p>\n<h2 id="-render-">通过 render 函数</h2>\n<p>基本思路是, render 根据地址栏的路径渲染组件内容, 配合 HTML5 的 history.pushState 的使用, 以及 popstate 事件的监听, 可以实现直接访问地址/浏览器返回前进/点击链接跳转的路由功能.</p>\n<p>优点: </p>\n<ol>\n<li>可以将不存在的地址转到 404.vue 页面.</li>\n</ol>\n<p>缺点: </p>\n<ol>\n<li>不支持 HTML5 的 hostory.pushState API 的浏览器无法 Polyfill. </li>\n<li>render 函数的渲染无法缓存起来.</li>\n</ol>\n<p>注意: 如果使用动画过渡效果 transition, 则根元素存在于 default.vue 中, 注意代码中和下面的区别.</p>\n<p>可查看 <a href="https://github.com/Xheldon/Framework/tree/master/VueSPA/app/NoRouter" target="_blank">具体代码</a></p>\n<h2 id="-component-is-">通过 component 的 is 属性</h2>\n<p>其实原理和上面的一样, 只是把 render 函数换成了component.</p>\n<p>component 组件有个 is 属性, 用来指示该 component 加载哪一个模板, 该属性可以自己通过逻辑, 来根据地址栏地址动态设置.</p>\n<p>优点:</p>\n<ol>\n<li>component 可以加上 keep-alive 属性来缓存起来, 比上面的 render 函数高效.</li>\n</ol>\n<p>缺点: </p>\n<ol>\n<li>不支持 HTML5 的 hostory.pushState API 的浏览器无法 Polyfill. </li>\n<li>无法渲染不存在的路由地址(如404等, 因此可以看到该 Demo 下没有像上面一样的 404.vue)</li>\n</ol>\n<p>注意: 如果使用动画过渡效果 transition, 则根元素存在于 tpl.html 中, 注意代码中和上面的区别.</p>\n<p>可查看 <a href="https://github.com/Xheldon/Framework/tree/master/VueSPA/app/NoRouterWithIs" target="_blank">具体代码</a></p>\n<h2 id="-vuerouter-">通过 VueRouter 插件</h2>\n<p>VueRouter 是官方插件, 完美实现了各种需求.</p>\n<p>优点: </p>\n<ol>\n<li>该有的功能都有.</li>\n</ol>\n<p>缺点:</p>\n<ol>\n<li>为了 Polyfill pushState, 在路径后面加了个 # 来实现路由功能, 实则不是真正的路由, 只是更改 hash 值.</li>\n</ol>\n<p>可查看 <a href="https://github.com/Xheldon/Framework/tree/master/VueSPA/app/Router" target="_blank">具体代码</a></p>\n'}});