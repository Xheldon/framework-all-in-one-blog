webpackJsonp([6],{82:function(s,a){s.exports='<h1 id="vue-">Vue 学习总结</h1>\n<p>date:   2016-06-01 22:13:35 +0800</p>\n<h3 id="-vue-framework-">分类: [Vue, Framework]</h3>\n<hr>\n<p>这篇文章从<a herf="https://cn.vuejs.org/v2/guide/instance.html" target="_blank"><code>Vue 2.0官方文档</code></a>的&quot;实例&quot;一节开始, 研究一些 <code>Vue API</code> 的使用方法, 以及 <code>Vue</code> 实现一些功能的原理, 此外还有自己的使用感受, 以及站在自己浅薄的角度分析 <code>Vue</code> 为什么要这么设计的不敬之举, 如有得罪还请海涵, 刚接触 <code>Vue</code> 不久, 不当之处烦请指出, 先行谢过.</p>\n<blockquote>\n<p>注意: 基础知识直接略过, 我只说我认为需要说的点.</p>\n</blockquote>\n<h2 id="vue-">Vue 实例</h2>\n<p>每个 <code>Vue.js</code> 的应用都是通过构造函数创建一个 <code>Vue</code> 的根实例启动的, 意思就是, 每个页面的数据都应该只由这一个实例维护, 原始数据的来源都应该只由根实例来发出和接收统一管理, 根实例再通过 <code>props</code>, 分发数据, 或者 <code>events</code> 来监听数据. 子组件只需要 <code>watch/computed</code> 数据变化, 及时更新即可.</p>\n<p>文档中说了一句话叫: <code>所有的 Vue.js 组件其实都是被扩展的 Vue 实例</code>, 这句话正确理解起来应该是, 你可以在组件上使用和实例一样的方法和钩子函数, 除了 <code>data</code> .</p>\n<p>组件中的 <code>data</code>, 必须是一个函数, 因为组件会被复用, 所以必须每次调用组件都生成一份数据. </p>\n<p>数据代理(proxy), 指的是 <code>Vue</code> 实例会代理其 <code>data</code> 对象中的所有属性, 而实例属性 <code>$data</code> 则表示 <code>data</code> 属性本身, 以区别被代理的 <code>data</code>.</p>\n<p>意思是, 如果一个 <code>vm</code> 的 <code>data</code> 属性为 <code>{a: &#39;xheldon&#39;}</code>, 那么 <code>vm.a</code> 即为 <code>&#39;xheldon&#39;</code>, 而 <code>vm.$data</code> 则为 <code>{a: &#39;xheldon&#39;}</code>.</p>\n<p>组件其实也是一个(被扩展的) <code>Vue</code> 实例, 下面是个简单的验证:</p>\n<p>有一个 <code>list.vue</code> 组件(<code>template</code> 和 <code>style</code> 省略):</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">\'vue\'</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{\n  data(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Vue);<span class="hljs-regexp">//</span><span class="hljs-literal">true</span>\n    <span class="hljs-keyword">return</span> {}\n  }\n  name: <span class="hljs-string">\'com-list\'</span>\n}\n</code></pre>\n<h2 id="props-vs-data">props vs data</h2>\n<p>初始化组件的时候, <code>prop</code> 上的属性和 <code>data</code> 上的属性以及 <code>computed</code> 的方法, 都被绑定到 <code>Vue</code> 实例上了, 但是 <code>porps</code> 上的属性, 优先级比 <code>data</code> 同名属性要高,下面是验证:</p>\n<pre><code class="hljs javascript">export <span class="hljs-keyword">default</span>{\n  <span class="hljs-keyword">data</span>(){\n    console.log(<span class="hljs-string">\'first:\'</span>,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//list 的实例</span>\n    <span class="hljs-keyword">return</span> {\n      a: <span class="hljs-string">\'a\'</span>,<span class="hljs-comment">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>\n      d: <span class="hljs-string">\'d\'</span>\n    }\n  },\n  props: [<span class="hljs-string">\'a\'</span>],<span class="hljs-comment">//和 data 中的 a 属性同名, 因此来自父级的数据将 data 中的同名属性 a 上的数据覆盖.(注:父级是根组件, 挂载在一个实例上)</span>\n  name: <span class="hljs-string">\'com-list\'</span>\n}\n</code></pre>\n<p>结果出现警告(不是报错, 不影响渲染):</p>\n<pre><code class="hljs javascript">[Vue warn]: The data property <span class="hljs-string">"a"</span> is already declared as a prop. Use prop<span class="hljs-built_in"> default </span>value instead.\n</code></pre>\n<p><img src="http://img.xheldon.com/img/propsVSdata.png" alt="props VS data" title="props VS data"></p>\n<p>而 <code>computed</code> 返回的函数名和 <code>data</code> 上的属性名可以重复, 并且不会有任何提示, 但是同名覆盖了之后, 因为在初始化的时候, 从控制台可以看到 <code>_data</code> 后于 <code>_computedWatcher</code> 来设置这个重复属性的 <code>getter</code> 和 <code>setter</code>(不知道是不是这个原因, 先放在这个地方以待我深入研究之后再修改这篇文章), 因此导致了被覆盖. 相关原理可以<a href="https://juejin.im/entry/577639de165abd00547b0924" target="_blank">看这篇介绍</a></p>\n<p>它们都在初始化的时候绑定到了实例 <code>属性</code> 上, 同名的 <code>computed</code> 属性被覆盖了, 但是 <code>Vue devtool</code> 仍然正确显示了出来)</p>\n<pre><code class="hljs javascript">export <span class="hljs-keyword">default</span>{\n  <span class="hljs-keyword">data</span>(){\n    console.log(<span class="hljs-string">\'first:\'</span>,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//list 的实例</span>\n    <span class="hljs-keyword">return</span> {\n      ab: <span class="hljs-string">\'a\'</span>,<span class="hljs-comment">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>\n    }\n  },\n  computed: {\n    ab(){\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'computed a\'</span>;<span class="hljs-comment">//方法名跟 data 上的 a 属性同名, 因此console 出来的 this 不会出现它的值, 用花括号输出的时候也是输出的 data 上的同名属性</span>\n    },\n    f(){\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'computed f\'</span><span class="hljs-comment">//方法名没有重复的, 因此 console 出来的 this 会有它的同名属性, 且值为 \'computed f\', 我们提供的 function 被作为该属性的 getter(计算属性默认只有 getter, 可以手动添加 setter)</span>\n    }\n  },\n  name: <span class="hljs-string">\'com-list\'</span>\n}\n</code></pre>\n<p><img src="http://img.xheldon.com/img/computedVSdata1.png" alt="computed VS data" title="computed VS data"></p>\n<p><code>Vue devtool</code> 正确显示了出来:</p>\n<p><img src="http://img.xheldon.com/img/computedVSdata3.png" alt="computed VS data" title="computed VS data"></p>\n<p>如果 <code>computed</code> 上的方法名和 <code>data</code> 上的属性名不重复:</p>\n<pre><code class="hljs javascript">export <span class="hljs-keyword">default</span>{\n  <span class="hljs-keyword">data</span>(){\n    console.log(<span class="hljs-string">\'first:\'</span>,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//list 的实例</span>\n    <span class="hljs-keyword">return</span> {\n      a: <span class="hljs-string">\'a\'</span>,<span class="hljs-comment">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>\n    }\n  },\n  computed: {\n    ab(){\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'computed a\'</span>;<span class="hljs-comment">//方法名跟 data 上的 a 属性同名, 因此 console 出来的 this 不会出现它的值, 但 Vue devtool 控制台正确显示了出来, 用花括号输出的时候也是其返回值 computed a.</span>\n    },\n    f(){\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'computed f\'</span><span class="hljs-comment">//方法名没有重复的, 因此 console 出来的 this 会有它的同名属性, 且值为 \'computed f\', 我们提供的 function 被作为该属性的 getter</span>\n    }\n  },\n  name: <span class="hljs-string">\'com-list\'</span>\n}\n</code></pre>\n<p><img src="http://img.xheldon.com/img/computedVSdata2.png" alt="computed VS data" title="computed VS data"></p>\n<p>此外, <code>methods</code> 和 <code>computed</code> 方法的区别除了后者有缓存而前者没有外(即后者除非其所依赖的响应式数据发生变化, 否则不会重新计算), 如果两者均是为了返回插值的话,则 <code>methods</code> 上的方法使用是 <code>functionName()</code>,\n而 <code>computed</code> 上的方法引用是 <code>functionName</code>, 即前者需要执行函数, 后者不需要执行.</p>\n<p>究其原因, 是因为 <code>computed</code> 属性上的我们写的方法, 被当做一个属性, 挂载到 <code>Vue</code> 实例上了, 而我们提供的函数, 被当做此方法的 <code>getter</code>.</p>\n<p>而 <code>methods</code> 不同, 它就是一个函数, 因此无论是插值引用, 还是事件方法, 都需要使用()来调用.</p>\n<p>这样的话, 当需要真正的函数------这里如果使用函数调用, 则 <code>computed</code> 需要返回一个函数不仅仅指是返回一个值, 而是需要传递参数------的时候, <code>metohds</code> 首当其冲.</p>\n<p>下面是一个不同于官网的另一个版本的 <code>todo list</code>:</p>\n<p>模板:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>\n  @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">"addToList"</span>\n  <span class="hljs-attr">v-model</span>=<span class="hljs-string">"todotext"</span>\n  /&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n  </span><span class="hljs-template-tag">{% <span class="hljs-name">raw</span> %}</span><span class="xml">\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, key) in todolist"</span>&gt;</span>\n    </span><span class="hljs-template-variable">{{key}}</span><span class="xml">:</span><span class="hljs-template-variable">{{value}}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"deletetodo(key)"</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  </span><span class="hljs-template-tag">{% <span class="hljs-name">endraw</span> %}</span><span class="xml">\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript">export <span class="hljs-keyword">default</span>{\n  <span class="hljs-keyword">data</span>(){\n    <span class="hljs-keyword">return</span>{\n      todolist:[],\n      todotext:<span class="hljs-string">\'\'</span>\n    }\n  },\n  methods: {\n    addToList(){\n      <span class="hljs-keyword">this</span>.todolist.push(<span class="hljs-keyword">this</span>.todotext);\n    },\n    deletetodo(key){\n      console.log(arguments);\n      <span class="hljs-keyword">this</span>.todolist.splice(key, <span class="hljs-number">1</span>);\n    }\n  }<span class="hljs-comment">/*,\n  computed:{\n    deletetodo(key){//不接收参数\n      console.log(arguments);\n      this.todolist.splice(key, 1);\n    }\n  }*/</span>\n}\n</code></pre>\n<p>此例子中, 如果使用这种模板, 则需要传递一个参数, 以在点击 <code>button</code> 的时候删除当前 <code>li</code>, 因此这个情况必须使用 <code>methods</code>.</p>\n<p>使用 <code>computed</code> 的时候, 不接受参数<a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/" target="_blank">(因为是一个 <code>getter</code>)</a>, 即使其返回一个 <code>function</code> :</p>\n<pre><code class="hljs javascript">computed:{\n  deletetodo(key){\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//控制台输出当前组件实例</span>\n      <span class="hljs-keyword">this</span>.todolist.splice(key, <span class="hljs-number">1</span>);<span class="hljs-comment">//报错</span>\n    }\n  }\n}\n</code></pre>\n<p>注意: 若两者存在同名函数, 那么 <code>computed</code> 上的函数优先级比 <code>methods</code> 高(处理 <code>getter</code> 和 <code>setter</code> 先后顺序的问题, 具体可查看源码), 这个情况无论是对插值还是事件绑定都适用, 以下是验证:</p>\n<p>插值引用测试:</p>\n<p>模板:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">{{a()}}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n</code></pre>\n<pre><code class="hljs javascript">methods:{\n  a(){\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'im from methods\'</span>\n  }\n},\ncomputed:{\n  a(){\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'im from computed\'</span>\n    }\n  }\n}\n</code></pre>\n<p>输出函数 <code>im from computed</code>, 如果 <code>computed</code> 不返回函数, 插值引用只使用 <code>{{a}}</code> 则显而易见更是输出 <code>computed</code> 的值, 验证此处略.</p>\n<p>事件绑定的时候:</p>\n<p>调用的时候使用<a href="https://cn.vuejs.org/v2/guide/events.html#内联处理器方法" target="_blank">内联处理器方法</a>:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">div</span> @click=<span class="hljs-string">"a()"</span>&gt;click <span class="hljs-keyword">me</span>&lt;/<span class="hljs-keyword">div</span>&gt;\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript">methods:{\n  a(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'methods\'</span>)\n  }\n},\n<span class="hljs-attr">computed</span>:{\n  a(){\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-comment">//computed 返回一个函数</span>\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'computed\'</span>)\n    }\n  }\n}\n</code></pre>\n<p>输出 <code>computed</code></p>\n<p>如果使用<a href="https://cn.vuejs.org/v2/guide/events.html#方法事件处理器" target="_blank">方法事件处理器</a>, 结果一样:</p>\n<pre><code class="hljs html">&lt;div @<span class="hljs-built_in">click</span>=<span class="hljs-string">"a"</span>&gt;<span class="hljs-built_in">click</span> me&lt;/div&gt;<span class="hljs-comment">//注意此处不带括号</span>\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript">methods:{\n  a(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'methods\'</span>)\n  }\n},\n<span class="hljs-attr">computed</span>:{\n  a(){\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-comment">//computed 返回一个函数</span>\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'computed\'</span>)\n    }\n  }\n}\n</code></pre>\n<p>输出 <code>computed</code></p>\n<p>注意事件绑定的时候, <code>computed</code> 都需要返回一个函数.</p>\n<p>因此优先级的顺序是:</p>\n<p><code>porps &gt; data &gt; computed &gt; methods</code></p>\n<p>我猜测在 <code>computed</code> 和 <code>methods</code> 中的 <code>this.xxx</code> 中的引用优先级也是相同的, 想搞明白的可以去验证下.</p>\n<p>而且可以看到, 两种情况 <code>method</code> 都不用返回一个 <code>function</code> , 而两种情况 <code>computed</code> 都需要返回一个 <code>function</code> 而且都不接受参数(因为是 <code>getter</code>). 综上所述, 事件处理最好使用 <code>methods</code>, 而数据绑定/插值处理 最好使用 <code>computed</code>(因为有缓存).</p>\n<p>此外, 对于 <code>method</code> 绑定事件的时候, 带()和不带()的效果是一样的, 都会执行其函数, 区别有以下几个:</p>\n<ol>\n<li><code>带()的叫内联语句</code>, 分两种情况, 原生事件和自定义事件. 两种情况都可以传参, 如果参数列表为空, 则默认参数 <code>arguments</code> 也为空, 即不存在默认参数; 如果是被一个原生事件如 <code>input/click</code> 触发的, 则可以传递一个特殊的 <code>$event</code> 参数作为原生 <code>event</code> 事件处理; 而如果是被一个自定义事件触发的, 其事件处理函数的参数仍然取决于实际传递给事件处理函数的值, 而且自定义函数不存在特殊的 <code>$event</code> 对象供使用. 由 <code>$emit</code> 触发自定义事件时传递的参数将被忽略.</li>\n<li><code>不带()叫方法事件</code>, 则分两种情况: 如果是原生事件, 则会传递原生 <code>event</code> 事件作为唯一的默认参数; 如果是自定义事件, 则传递的是 <code>$emit</code> 事件的时候除了事件名外的第二到最后一个任意数量的参数.</li>\n</ol>\n<blockquote>\n<p>talk is cheap, show me the code</p>\n</blockquote>\n<p>上面说的是四个情况:</p>\n<p>1.带()的原生事件</p>\n<pre><code class="hljs javascript">&lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-meta">@click</span>=<span class="hljs-string">"test1()"</span>&gt;<span class="hljs-comment">//模板里面传参为空</span>\nmethods:{\n  test1(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//则逻辑中的参数也为空;</span>\n  }\n}\n</code></pre>\n<p>2.带()的自定义事件</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">//子模板</span>\n&lt;input type=<span class="hljs-string">"text"</span> @input=<span class="hljs-string">"shuru($event)"</span>/&gt;\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{xheldon}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n<span class="hljs-comment">//子逻辑:</span>\nname: <span class="hljs-string">\'child\'</span>,\n<span class="hljs-attr">props</span>:[<span class="hljs-string">\'xheldon\'</span>],\n<span class="hljs-attr">method</span>:{\n  shuru(e){\n    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'haha\'</span>, e.target.value,<span class="hljs-string">\'其他参数\'</span>);\n  }\n}\n<span class="hljs-comment">//父模板</span>\n&lt;child :xheldon=<span class="hljs-string">"blob"</span> @haha=<span class="hljs-string">"something()"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span>\n<span class="hljs-comment">//父逻辑:</span>\nmethods:{\n  something(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'parent:\'</span>,...arguments);<span class="hljs-comment">//上面 something() 中传 xxx, 则输出 \'parent:xxx\', 即忽略了子组件 $emit 事件时候传递的参数.</span>\n    <span class="hljs-keyword">this</span>.blob = <span class="hljs-built_in">arguments</span>;\n  }\n}\n</code></pre>\n<p>3.不带()的原生事件</p>\n<pre><code class="hljs javascript">&lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-meta">@click</span>=<span class="hljs-string">"test1"</span>&gt;\nmethods:{\n  test1(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//结果: 输出原生的 MouseEvent 事件</span>\n  }\n}\n</code></pre>\n<p>4.不带()的自定义事件</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">//子模板</span>\n&lt;input type=<span class="hljs-string">"text"</span> @input=<span class="hljs-string">"shuru($event)"</span>/&gt;\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{xheldon}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n<span class="hljs-comment">//子逻辑:</span>\nname: <span class="hljs-string">\'child\'</span>,\n<span class="hljs-attr">props</span>:[<span class="hljs-string">\'xheldon\'</span>],\n<span class="hljs-attr">method</span>:{\n  shuru(e){\n    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'haha\'</span>, e.target.value,<span class="hljs-string">\'其他参数\'</span>);\n  }\n}\n<span class="hljs-comment">//父模板</span>\n&lt;child :xheldon=<span class="hljs-string">"blob"</span> @haha=<span class="hljs-string">"something"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span>\n<span class="hljs-comment">//父逻辑:</span>\nmethods:{\n  something(){\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'parent:\'</span>,...arguments);<span class="hljs-comment">//input 输入 xxx, 则输出 \'parent: xxx 其他参数\', 即与子组件 $emit 时候传递的参数相关.</span>\n    <span class="hljs-keyword">this</span>.blob = <span class="hljs-built_in">arguments</span>;\n  }\n}\n</code></pre>\n<h2 id="-">指令和参数(属性)</h2>\n<p>基本用法:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">div</span> v-directive:propNamed.modifiers=<span class="hljs-string">"value"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;\n</code></pre>\n<p>其中, <code>directive</code> 叫做指令, <code>propName</code> 叫做指令的&quot;参数&quot;, 实际上参数的具体表现就是 <code>html</code> 上的属性(<code>Vue</code> 内置了一些参数/属性, 如 <code>v-bind:click=&quot;method&quot;</code>, 的 <code>click</code>, 如 <code>v-bind:href=&quot;/img/x.png&quot;</code> 的 <code>href</code>, 前者不会出现在行内, 而后者因为是必须的因此会出现在行内属性. 而自己定义的参数/属性, 一定会出现在行内属性). 而 <code>value</code> 是个变量(虽然它写在双引号中)大多数情况下来自于父级模板.</p>\n<p><code>propName</code> 可以带个修饰符, 用来快捷操作一些行为如禁止默认事件 <code>.prevent</code> 等.</p>\n<p>有些指令可以直接使用如 <code>v-if</code>, 有些必须加上参数: <code>v-bind:href/v-on:click</code></p>\n<p>注意, <code>value</code> 带不带双引号结果都是一样的, 即 <code>:propName=&quot;value&quot;</code> 和 <code>:propName=value</code> 是一样的, 除特殊说明, 下列所有情况均适用.</p>\n<p>如果 <code>value</code> 转换成布尔值后为 <code>false</code> 则 <code>propName</code> 被移除, 为 <code>true</code> 则该 <code>propName</code> 出现, 实际上, 它遵守以下规则(仅限自定义属性):</p>\n<p>1.<code>null</code>, <code>undefined</code>, <code>false</code> 的直接量, <code>propName</code> 属性被移除.\n2.<code>value</code> 为一个未定义的变量, 如 <code>:propName=&quot;wxd&quot;</code> 则 <code>propName</code> 移除, 且出现警告:</p>\n<pre><code class="hljs javascript">[Vue warn]: Property <span class="hljs-keyword">or</span> method <span class="hljs-string">"s"</span> is <span class="hljs-keyword">not</span> defined on the<span class="hljs-built_in"> instance </span>but referenced during render. Make sure <span class="hljs-keyword">to</span> declare reactive data properties <span class="hljs-keyword">in</span> the data option.\n</code></pre>\n<p>3.如果 <code>value</code> 为一个数组, 因为数组为对象, 因此 <code>propName</code> 除了下面第二种情况外, 恒存在, 而 <code>value</code> 分以下情况:</p>\n<ol>\n<li><p><code>:propName =[]</code>, <code>:propName =&quot;[]&quot;</code>, <code>:propName =&quot;[&#39;&#39;]&quot;</code> <code>value</code> 移除, 即只有属性没有值.</p>\n</li>\n<li><p><code>:propName =[&quot;&quot;]</code>, 结构乱掉.</p>\n</li>\n<li><p><code>:propName =[&quot;&quot;,&quot;&quot;]</code> 或者 <code>:propName =&#39;[&quot;&quot;,&quot;&quot;]&#39;</code>, <code>value</code> 值为<code>&quot;,&quot;</code></p>\n</li>\n<li><p>如果 <code>value</code> 为一个嵌套数组, 则其值被一维化后, 如果 <code>value</code> 包含及其递归子元素包含一个为 <code>undefined</code> 或者 <code>null</code> 直接量(不是写到字符串里面的), 则该处的值留空; 如果 <code>value</code> 包含及其递归子元素包含一个 <code>Object</code>, 则该处的值为 <code>[object Object]</code></p>\n</li>\n</ol>\n<p>4.如果 <code>value</code> 为一个对象, 则 <code>propName</code> 保留, 值为 <code>[object Object]</code></p>\n<p>5.如果 <code>value</code> 为一个数字或者字符串, 如 <code>:propName = &quot;&#39;fff&#39;&quot;</code>, 则 <code>propName</code> 保留, <code>value</code>为字符串或数字值.</p>\n<p>看了下源码, 也确实是这么个逻辑:</p>\n<pre><code class="hljs javascript">function setAttr (el, <span class="hljs-built_in">key</span>, value) {\n  <span class="hljs-keyword">if</span> (isBooleanAttr(<span class="hljs-built_in">key</span>)) {\n    <span class="hljs-comment">// set attribute for blank value</span>\n    <span class="hljs-comment">// e.g. &lt;option disabled&gt;Select one&lt;/option&gt;</span>\n    <span class="hljs-keyword">if</span> (isFalsyAttrValue(value)) {\n      el.removeAttribute(<span class="hljs-built_in">key</span>);\n    } <span class="hljs-keyword">else</span> {\n      el.setAttribute(<span class="hljs-built_in">key</span>, <span class="hljs-built_in">key</span>);\n    }\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isEnumeratedAttr(<span class="hljs-built_in">key</span>)) {\n    el.setAttribute(<span class="hljs-built_in">key</span>, isFalsyAttrValue(value) || value === <span class="hljs-string">\'false\'</span> ? <span class="hljs-string">\'false\'</span> : <span class="hljs-string">\'true\'</span>);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isXlink(<span class="hljs-built_in">key</span>)) {\n    <span class="hljs-keyword">if</span> (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(<span class="hljs-built_in">key</span>));\n    } <span class="hljs-keyword">else</span> {\n      el.setAttributeNS(xlinkNS, <span class="hljs-built_in">key</span>, value);\n    }\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">if</span> (isFalsyAttrValue(value)) {\n      el.removeAttribute(<span class="hljs-built_in">key</span>);\n    } <span class="hljs-keyword">else</span> {\n      el.setAttribute(<span class="hljs-built_in">key</span>, value);\n    }\n  }\n}\n</code></pre>\n<p>这些规则仅限自定义属性, 如果是内置属性, 则又不同, 比如绑定 <code>class</code> 属性:</p>\n<pre><code class="hljs javascript">v-<span class="hljs-string">bind:</span><span class="hljs-class"><span class="hljs-keyword">class</span>="{</span><span class="hljs-string">active:</span> isActive}<span class="hljs-string">"</span>\n</code></pre>\n<p>则表示如果 <code>isActive</code> 值为是 <code>false</code> 或者是其他可以转换成布尔值 <code>false</code> 的值, 则 <code>active</code> 这个类名不应用, 反之, 则应用该类名(同 if 语句的真假判定一致).</p>\n<h2 id="-">过滤器</h2>\n<p>过滤器串联起来的话, 第一个过滤器的参数是初始值, 随后的过滤器第一个参数为上一个过滤器的返回值, 没有返回值则为 <code>undefined</code>.</p>\n<p>模板:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">div</span> v-bind:<span class="hljs-keyword">prop</span>=<span class="hljs-string">"rawProp | filterOne | filterTwo"</span>&gt;控制台查看 filter 函数的参数&lt;/<span class="hljs-keyword">div</span>&gt;\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  data(){\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">rawProp</span>: <span class="hljs-string">\'this is raw prop\'</span>\n    }\n  },\n  <span class="hljs-attr">filters</span>: {\n    filterOne(){\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'this param is pass to next filter\'</span>\n    },\n    filterTwo(){\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);\n    },\n  },\n  <span class="hljs-attr">name</span>: <span class="hljs-string">\'com-header\'</span>,\n}\n</code></pre>\n<p>除了第一个 <code>filter</code> ,后面的 <code>filter</code> 没有办法获取到初始值. 当然, 如果你想传参数, 办法有的是, 比如第一个 <code>filter</code> 返回一个数组等等.</p>\n<h2 id="-">列表渲染</h2>\n<p><code>v-for</code> 中, 如果参数是两个, 则是和原生 <code>js</code> 中的 <code>forEach</code> 参数一致, 是 <code>value, key</code>, 而使用 <code>of</code> 操作符和使用 <code>in</code> 操作符的效果完全一样------虽然在原生 <code>js</code> 中并不是.</p>\n<p>还有个需要注意的地方是, 组件使用 <code>v-for</code> 的时候, 父级是不能自动传递数据到组件的, 因为组件有自己的独立作用域. 因此你为了传递数据给子组件用, 需要使用 <code>props</code> 属性写的稍微麻烦一点:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">my</span>-component\n  v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(item, index) in items"</span>\n  v-<span class="hljs-keyword">bind</span>:item=<span class="hljs-string">"item"</span>\n  v-<span class="hljs-keyword">bind</span>:<span class="hljs-keyword">index</span>=<span class="hljs-string">"index"</span>&gt;\n&lt;<span class="hljs-regexp">/my-component&gt;</span>\n</code></pre>\n<p>另外, <code>v-for</code> 使用在对象上面的时候, 迭代值是对象的值, 而不是键, 这个和原生 <code>js</code> 不一样, 原生 <code>js</code> 的 <code>for in</code> 循环若要输出值, 需要你手动遍历 <code>obj[&#39;i&#39;]</code>, 而想要输出键需要写第二个参数<code>(value, key)</code>:</p>\n<pre><code class="hljs js">obj:{\n  first: <span class="hljs-string">\'xheldon\'</span>,\n  last: <span class="hljs-string">\'cao\'</span>,\n  age: <span class="hljs-string">\'25\'</span>\n}\n&lt;div v-for=<span class="hljs-string">"(value, key) in obj"</span>&gt;{% raw %}{{value}}-{{key}}{% endraw %}&lt;/div&gt;// 输出 xheldon cao <span class="hljs-number">25</span>\n</code></pre>\n<p>注意, 原生 <code>js</code> 除非你手动实现了一个 <code>Symbol.iterator</code>, 否则是不能使用 <code>for of</code> 循环的, 但是 <code>Vue</code> 可以------虽然效果和 <code>for in</code> 完全一样.</p>\n<p>列表渲染还有一个小 <code>tips</code> 叫就地复用原则, 什么意思呢? 还是拿上面说的 <code>tololist</code> 说, 如果没有给每个元素指定一个独一无二的 <code>key</code> 值, 就像这样:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, key) in todolist"</span>&gt;</span></span><span class="hljs-template-variable">{{value.key}}</span><span class="xml">:</span><span class="hljs-template-variable">{{value.value}}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"deletetodo(key)"</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>\n</code></pre>\n<p>那么每次点击这个叉叉删除当前 <code>li</code> 的时候, <code>Vue</code> 都会就地复用当前的元素, 直接移动数据到正确的位置, 而不是 <code>remove</code> 删除的 <code>dom</code> 元素, 避免 <code>reflow</code>, 下面是使用 <code>chrome</code> 的 <code>devtool</code> 工具显示的当点击叉叉删除元素的时候, 页面 <code>render</code> 的情况:</p>\n<p><img src="http://img.xheldon.com/img/nokey.png" alt="没有key" title="没有key"></p>\n<p>可以看到 <code>reflow</code> 的部分只有最下面那一点</p>\n<p>而当加上 <code>key</code> 之后:</p>\n<pre><code class="hljs html">&lt;li <span class="hljs-attribute">v-for</span>=<span class="hljs-string">"(value, key) in todolist"</span> :<span class="hljs-attribute">key</span>=<span class="hljs-string">"value.key"</span>&gt;{%<span class="hljs-built_in"> raw </span>%}{{value.key}}:{{value.value}}{% endraw%}&lt;button @<span class="hljs-attribute">click</span>=<span class="hljs-string">"deletetodo(key)"</span>&gt;X&lt;/button&gt;&lt;/li&gt;\n</code></pre>\n<p>再看点击叉叉之后浏览器的 <code>render</code> 的情况:</p>\n<p><img src="http://img.xheldon.com/img/key.png" alt="有key" title="有key"></p>\n<p>有人可能会有疑惑, 为什么这个地方需要自己手动实现一个 <code>value</code> 上的 <code>value.key</code>, 而不是使用 <code>Vue</code> 给的 <code>(value, key)</code> 中的 <code>key</code> 呢?:</p>\n<pre><code class="hljs html">{%<span class="hljs-built_in"> raw </span>%}\n&lt;li <span class="hljs-attribute">v-for</span>=<span class="hljs-string">"(value, key) in todolist"</span> :<span class="hljs-attribute">key</span>=<span class="hljs-string">"key"</span>&gt;{{value.key}}:{{value.value}}&lt;button @<span class="hljs-attribute">click</span>=<span class="hljs-string">"deletetodo(key)"</span>&gt;X&lt;/button&gt;&lt;/li&gt;\n{% endraw %}\n</code></pre>\n<p>答案是, <code>Vue</code> 给的 <code>key</code>, 看起来是个 <code>key</code>, 但是还是跟当前数据是无关的, 因此当删除一个 <code>li</code> 的时候, <code>key</code> 仅仅只是重新算了一下, 并没有跟着删除的或者被删除的元素移除或者上移下移. 如果使用上面的写法, 效果和第一种没有 <code>key</code> 的是一样的, 仍然使用了就地复用策略, 变动的还是数据, 不变的还是 <code>dom</code> 结构, 因此你需要手动实现一个 <code>key</code>, 大致是这样的:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">data</span>(){\n  <span class="hljs-keyword">return</span>{\n    toolist:[],\n    truekey: <span class="hljs-number">0</span>,<span class="hljs-comment">//手动实现一个 key</span>\n    todotext: <span class="hljs-string">\'\'</span>\n  }\n},\nmethods: {\n  addTolist(){\n    <span class="hljs-keyword">this</span>.todolist.push({value:<span class="hljs-keyword">this</span>.todotext, key: ++<span class="hljs-keyword">this</span>.truekey});<span class="hljs-comment">// 把 key 放到 data 上</span>\n  }\n}\n</code></pre>\n<h2 id="-">事件处理器</h2>\n<p>事件处理器可以串联, 但是有些元素本身不支持, 因此绑定了也没有意义, 如在 <code>div</code> 上绑定一个 <code>keyup</code> 事件:</p>\n<pre><code class="hljs javascript">&lt;<span class="hljs-selector-tag">div</span> @keyup.alt=<span class="hljs-string">"pressalt"</span>&gt;<span class="hljs-selector-tag">div</span> alt 按键测试&lt;/div&gt;\n</code></pre>\n<p>因此一般是在 <code>div</code> 上冒泡处理事件, 然后在一个 <code>input</code> 上绑定一个 <code>alt+ctrl</code> 事件:</p>\n<pre><code class="hljs javascript">&lt;<span class="hljs-keyword">div</span> @keyup.alt=<span class="hljs-string">"presskey"</span>&gt;<span class="hljs-keyword">div</span>冒泡按键测试\n  &lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span>&gt;\n&lt;/<span class="hljs-keyword">div</span>&gt;\n</code></pre>\n<p>我对此有个担心, 就是如果一个 <code>input</code> 使用了 <code>@keyup.space</code> 的监听, 但是中文输入法中空格一般是用来选中词语的, 那实际输出的是还未选中词语的拼音字母, 还是按下空格后, 候选列表的第一个词语呢?(貌似这个不是 <code>Vue</code> 的问题, 但是还是在这儿提出来了)</p>\n<p>答案是, 大多数情况下, 结果是按下空格后的第一个词语, 但是如果一句话很长的话, 需要按两次 <code>space</code> 来输出一句话, 则第一次按的时候, 什么也不会输出, 是个空的, 第二次按下 <code>space</code> 才输出全部的词汇. 我这里是为了测试的极端情况, 因此基本可以认为按下空格后的第一个词语, 而不是空白, 或者拼音字母. 我使用的是搜狗 <code>mac</code> 输入法的单行候选词模式, 可以用上面的 <code>todolist</code> 来测试(略)</p>\n<p>注: 官网文档讲 <code>v-model</code> 的时候会讲到 <code>IME</code>, 说的就是这个问题, 如果希望使用输入法的时候, <code>v-model</code> 也即时响应, 那么可以绑定 <code>input</code> 事件.</p>\n<h2 id="-">表单控件</h2>\n<p><code>v-model</code> 一般用在 <code>input</code> 上面, 而模板中的 <code>input</code> 的 <code>value</code> 值会被忽略------ <code>v-model</code> 只认在 <code>js</code> 中的初始值, 并与之绑定, 因此如果你写了 <code>v-model</code>, 又写了 <code>value</code> 属性, 则后者虽然会出现在 <code>dom</code> 结构中, 但是 <code>js</code> 获取其值的时候会忽略掉它而取 <code>v-model</code> 绑定的值:</p>\n<pre><code class="hljs html">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">"我出现在 dom 结构的 value 属性中, 但是只能通过 getAttribute 获取到我, .value 并不能获取到, 伤心~"</span>&gt;\n</code></pre>\n<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">data</span>(){\n  <span class="hljs-title">return</span>{\n    <span class="hljs-title">todotext</span>:\'我是真正的初始值, <span class="hljs-title">js</span> 获取的是我, 虽然我并不出现在 <span class="hljs-title">dom</span> 中的 <span class="hljs-title">value</span> 属性中~\',\n  }</span>\n}\n</code></pre>\n<p>二者的区别类似于 <code>jQuery</code> 中的, <code>.data</code> 和 <code>.attr</code> 的区别------写在行内的是 <code>attr(&#39;data&#39;,&#39;xxx&#39;)</code>的值, 查看 <code>dom</code> 结构看到的也是 <code>xxx</code> 的值, 但是 <code>js</code> 获取到的实际的值是通过 <code>js</code> 绑定的 <code>.data(&#39;yyy&#39;)</code> 的值------当然除非你使用 <code>attr</code> 读取 <code>dom</code> 结构.(注意, 实例化之后再修改 <code>attr</code> 的值, <code>js</code> 获取到的就是 <code>attr</code> 的值了, 这里的忽略初始值, 仅仅是忽略初始值而已, 举个例子就是初始化之后的 <code>v-model</code> 绑定了 <code>value</code> 之后, 手动修改 <code>dom</code> 结构的 <code>value</code> 值, 那 <code>v-model</code> 再获取该元素的 <code>value</code> 值就会使用修改后的 <code>attr</code> 属性值, 而不是 <code>data</code> 上面的值).</p>\n<p>如果需求比较奇葩, 不想通过 <code>v-model</code> 获取 <code>input</code> 的值, 然后实时更新, 或者需要获取 <code>input</code> 的值处理后再更新, 同时不想使用 <code>v-model</code>, 可以试试 <code>$ref</code>(<code>e.target.value</code> 也是可以的):</p>\n<p>模板:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-keyword">input</span> @<span class="hljs-keyword">input</span>=<span class="hljs-string">"input"</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">"inputvalue"</span> /&gt;\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">data</span>(){\n  message: <span class="hljs-string">\'\'</span>\n},\nmethods:{\n  input(){\n    <span class="hljs-keyword">this</span>.message = <span class="hljs-keyword">this</span>.$refs.inputvalue.value;\n  }\n}\n</code></pre>\n<p>官网文档也说了, <code>v-model</code> 只是一个实现双向数据绑定的语法糖:</p>\n<pre><code class="hljs html">&lt;input v-bind:<span class="hljs-attribute">value</span>=<span class="hljs-string">"something"</span> v-on:<span class="hljs-attribute">input</span>=<span class="hljs-string">"something = <span class="hljs-variable">$event</span>.target.value"</span>&gt;\n</code></pre>\n<p>不过监听 <code>input</code> 事件, 导致的问题是使用输入法的时候, 在没按空格选中词语的时候, 也会触发输入的事件, 所以如果没有这个需求, 还是老老实实用 <code>v-model</code> 的好.</p>\n<p>如果需要多个元素绑定相同的值并输出, 常见的需求是一组 <code>checkbox</code>, 这个时候需要使用数组:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-built_in">input</span> v-model=<span class="hljs-string">"messages"</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">"checkbox"</span> value=<span class="hljs-string">"xheldon"</span> /&gt;\n&lt;<span class="hljs-built_in">input</span> v-model=<span class="hljs-string">"messages"</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">"checkbox"</span> value=<span class="hljs-string">"xiaodan"</span> /&gt;\n<span class="hljs-symbol">&lt;p&gt;</span>{{<span class="hljs-keyword">messages</span>}}&lt;/<span class="hljs-keyword">p</span>&gt;\n</code></pre>\n<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">data</span>(){\n  <span class="hljs-title">return</span>{\n    <span class="hljs-title">messages</span>: []\n  }</span>\n}\n</code></pre>\n<p>(目前我发现的)这种如此简洁的数组用法仅仅对多个 <code>checkbox</code> 类型的 <code>input</code> 有效------即几个元素绑定相同的 <code>v-model</code>, 但是这几个元素的状态却没有同步, 而是将对应的 <code>value</code> 放到数组中. 当然如果你强行说, 我用 <code>methods</code> 方法可以实现任意输入类型的元素完成类似效果------那当我没说.</p>\n<p>单个的 <code>checkbox</code> <code>v-model</code> 绑定的是 <code>value</code> 值, 为 <code>true</code> 或者 <code>false</code>, 可以通过 <code>:true-value</code> 和 <code>:false-value</code> 来自定义选中时候的值和没有选中时候的值.</p>\n<p>而多个单选框 <code>radio</code> 中的 <code>v-model</code> 起到了类似 <code>name</code> 的作用------即用来分组, 所以 <code>radio</code> 类型的 <code>input</code> 使用 <code>v-model</code> 的话就不用写 <code>name</code> 属性.</p>\n<p><code>select</code> 类型的如果没有给定每个 <code>option</code> 的 <code>value</code> 属性, 则绑定的是 <code>option</code> 中的值, 如果给了则就是 <code>value</code> 的属性值. <code>select</code> 类型的多选框 <code>v-model</code> 绑定的 <code>data</code> 必须是一个数组类型, 否则会给出警告(但不会报错, <code>Vue</code> 自动转换, 还是能正常运行):</p>\n<pre><code class="hljs javascript"><span class="hljs-symbol">Vue</span> warn]: &lt;<span class="hljs-keyword">select </span><span class="hljs-keyword">multiple </span>v-model=<span class="hljs-string">"selectM"</span>&gt; expects an Array value for <span class="hljs-keyword">its </span><span class="hljs-keyword">binding, </span><span class="hljs-keyword">but </span>got <span class="hljs-keyword">String</span>\n</code></pre>\n<p>注意, 以上所有类型的 <code>v-model</code> 和 <code>value</code> 绑定时, 而 <code>value</code> 属性又动态 (<code>:value=&quot;xxx&quot;</code>)绑定了 <code>data</code> 上的其他(<code>xxx</code>)属性, 则 <code>v-model</code> 对应的属性和 <code>:value</code> 对应的属性是同一个(严格相等).</p>\n<h2 id="-">组件</h2>\n<p>首先需要区分的是, 什么是 <code>DOM</code> 模板, 什么是字符串模板.</p>\n<p><code>HTML</code> 模板指的是普通的 <code>html</code> 中的元素, 这些元素会通过 <code>Vue</code> 实例的 <code>el</code> 选项进行绑定:\n字符串模板部分:</p>\n<pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">"tpl"</span>&gt;  实例挂载元素\n  html 自有组件:\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>\n  自定义组件:\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n</code></pre>\n<p>字符串模板指的是:</p>\n<p>1.<code>js</code> 中通过 <code>template</code> 注册的模板如: </p>\n<pre><code class="hljs javascript"><span class="hljs-selector-tag">Vue</span><span class="hljs-selector-class">.component</span>(<span class="hljs-string">\'my-component\'</span>, {\n  <span class="hljs-attribute">template</span>: <span class="hljs-string">\'&lt;span&gt;{{message}}&lt;/span&gt;\'</span>,\n  data(){\n    <span class="hljs-attribute">message</span>: <span class="hljs-string">\'hello, xheldon\'</span>\n  }\n});\n</code></pre>\n<p>或者:</p>\n<pre><code class="hljs javascript">var Child = {\n  template: <span class="hljs-string">\'&lt;div&gt;\'</span>hello, xheldon<span class="hljs-string">\'&lt;/div&gt;\'</span>\n}\nnew Vue({\n  components: {\n    <span class="hljs-string">\'my-component\'</span>: Child\n  }\n})\n</code></pre>\n<p>2.通过<code>&lt;script type=&quot;text/x-tempalge&quot;&gt;&lt;/script&gt;</code>注册的模板(和 <code>Handlebar</code> 一样)</p>\n<p>3.<code>.vue</code> 组件中的 <code>&lt;template&gt;</code> 标签内的内容.</p>\n<p>因为 <code>Vue</code> 是在浏览器解析完毕之后才开始解析 <code>DOM</code> 模板的, 因此 <code>DOM</code> 模板在一些需要特定子元素的标签上不能使用组件. 如 <code>select</code> 标签下的子元素必须为 <code>option</code>, 因此用自定义标签 <code>com-option</code> 则不会识别, 因此可以增加一个 <code>is=&quot;component-name&quot;</code> 属性, 表明该标签使用的模板名字即可.</p>\n<h2 id="-vs-">字面量语法 VS 动态语法</h2>\n<p>这里需要注意个问题, 即在原生 <code>js</code> 中, 对象的属性是可以为数字的, 只是其会被当成是字符串(仅限 <code>ES5</code>, <code>ES6</code> 中对象属性可以为任意值, 不过和之后要说的不冲突). 但是在 <code>Vue</code> 中, <code>data</code> 属性上不能使用数字作为属性, 如果是字面量语法, 传递数字会被先 <code>toString</code> 处理, 而如果是动态语法, 则会直接当做是数字处理, 不会寻找 <code>data</code> 上绑定的属性值:</p>\n<p>子组件模板:</p>\n<pre><code class="hljs html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">{{dynamic}}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"alertProp"</span>&gt;</span> 点我看上面 props 传参的类型<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n</code></pre>\n<p>子组件逻辑:</p>\n<pre><code class="hljs javascript">props:[<span class="hljs-string">\'dynamic\'</span>],\nmethods:{\n  alertProp(){\n    alert(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">dynamic</span>)<span class="hljs-comment">//上面说过了, props 属性也是绑定到 Vue 实例上的, 因此可以直接使用 this</span>\n  }\n}\n</code></pre>\n<p>父组件-字面量语法:</p>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">com-child</span> <span class="hljs-attr">dynamic</span>=<span class="hljs-string">"11"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com-todolist</span>&gt;</span>\n</code></pre>\n<p>父组件-动态语法:</p>\n<pre><code class="hljs html">&lt;com-child <span class="hljs-symbol">:dynamic=<span class="hljs-string">"11"</span>&gt;&lt;/com-todolist&gt;</span>\n</code></pre>\n<p>以上两种语法下父组件逻辑均为:</p>\n<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">data</span>(){\n  <span class="hljs-title">return</span> {\n    11:\'属性-动态语法\'\n  }</span>\n}\n</code></pre>\n<p>结果是, 当使用父组件字面量语法毫无疑问点击 <code>button</code> 的时候传递给子组件的是 <code>1</code>, 而且文档也说了, 是字符串的 <code>1</code>, 因此 <code>alert</code> 出来的是 <code>string</code>; 而当父组件动态语法使用 <code>v-bind</code> 绑定了父组件 <code>data</code> 的 <code>1</code> 属性, 但是子组件并没有接收到 <code>1</code> 属性对应的 <code>属性-动态语法</code> 这个值, 而还是 <code>1</code> 这个值,  因此点击 <code>button</code> 时候 <code>alert</code> 出来的是 <code>number</code>.</p>\n<p>结论: 最好不要使用数字作为 <code>data</code> 对象的属性.</p>\n<p>注意: 如果传递给子组件属性的是一个数组或者对象, 在子组件中修改这个属性值, 则会反映到父组件上------这通常是不应该的, 因为俗话说得好: <code>props down, events up</code>(举例略), 最佳实践应该是使用父组件传递过来的引用类型的深拷贝------当然如果你就是需要子组件影响父组件的状态, 那我祝你好运.</p>\n<p><code>events up</code> 的时候, 如果子组件 <code>$emit</code> 的时候传递了除了事件名之外的其他参数, 则这些参数会被传递给父组件的事件监听函数:</p>\n<p>子组件模板:</p>\n<pre><code class="hljs javascript"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">"someEventHandlerForOriginalEventLikeClickOrInput($event)"</span>/&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">{{data}}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>\n</code></pre>\n<p>子组件逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-string">props:</span>[<span class="hljs-string">\'data\'</span>],\n<span class="hljs-string">methods:</span>{\n  someEventHandlerForOriginalEventLikeClickOrInput(e){\n    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'eventPasstoParent\'</span>, e.target.value, <span class="hljs-string">\'someOtherArgus\'</span>);\n  } \n}\n</code></pre>\n<p>父级模板:</p>\n<pre><code class="hljs html">&lt;com-todolist :<span class="hljs-attribute">data</span>=<span class="hljs-string">"someParentData"</span> @<span class="hljs-attribute">eventPasstoParent</span>=<span class="hljs-string">"someParentEventHandler"</span>&gt;&lt;/com-todolist&gt;\n</code></pre>\n<p>父级逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-string">someParentData:</span> <span class="hljs-string">\'\'</span>\n<span class="hljs-string">methods:</span>{\n  someParentEventHandler(){\n    <span class="hljs-keyword">this</span>.someParentData = [...arguments];\n  } \n}\n</code></pre>\n<h2 id="-">异步更新队列</h2>\n<p>有了 <code>Vue</code>, 就不再需要 <code>jQuery</code> 了, 框架的最大好处是避免了我们对相同操作的写出重复的代码. 双向数据绑定可以帮我们解决很多 <code>DOM</code> 操作问题, 但是有些情况下 <code>jQuery</code> 却更有优势, 比如操作 <code>DOM</code> 的时候, <code>jQuery</code> 会接收一个函数作为回调函数, 动画执行完成的时候触发. 而我们使用的双向数据绑定, 设置完数据之后, 如何知道 <code>DOM</code> 已经更新了呢? 答案和 <code>jQuery</code> 一样, 就是异步更新队列.</p>\n<pre><code class="hljs javascript">var <span class="hljs-keyword">vm</span> = <span class="hljs-keyword">new</span> Vue({\n  <span class="hljs-keyword">e</span><span class="hljs-variable">l:</span> <span class="hljs-string">\'#example\'</span>,\n  dat<span class="hljs-variable">a:</span> {\n    message: <span class="hljs-string">\'123\'</span>\n  }\n})\n<span class="hljs-keyword">vm</span>.message = <span class="hljs-string">\'new message\'</span> // 更改数据\n<span class="hljs-keyword">vm</span>.$<span class="hljs-keyword">el</span>.textContent === <span class="hljs-string">\'new message\'</span> // false\nVue.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>\n  <span class="hljs-keyword">vm</span>.$<span class="hljs-keyword">el</span>.textContent === <span class="hljs-string">\'new message\'</span> // true\n})\n</code></pre>\n<p>这么写我个人是不推荐的, 因为我认为最好的逻辑是写到实例的属性/方法里面, 而不是写到实例的外面, 还好 <code>Vue</code> 给我们提供了实现方式:</p>\n<pre><code class="hljs javascript">Vue.component(<span class="hljs-string">\'example\'</span>, {\n  <span class="hljs-attr">template</span>: <span class="hljs-string">\'&lt;span&gt;{{ message }}&lt;/span&gt;\'</span>,\n  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">message</span>: <span class="hljs-string">\'not updated\'</span>\n    }\n  },\n  <span class="hljs-attr">methods</span>: {\n    <span class="hljs-attr">updateMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">this</span>.message = <span class="hljs-string">\'updated\'</span>\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$el.textContent) <span class="hljs-comment">// =&gt; \'没有更新\'</span>\n      <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$el.textContent) <span class="hljs-comment">// =&gt; \'更新完成\'</span>\n      })\n    }\n  }\n})\n</code></pre>\n<h2 id="-">动画</h2>\n<p>动画没什么好说的, 主要是 <code>JavaScript</code> 钩子函数中的两个钩子需要说下, 一个是 <code>enterCanceled</code> 和 <code>leaveCancelled</code>. <code>enterCancelled</code> 在 <code>v-if</code> 和 <code>v-show</code> 中使用, 均可能触发, 而触发时机, 是触发 <code>enter</code> 的事件之后, 在动画还没有执行完的过程中, 又需要执行其他动画的时候. 而 <code>leaveCancelled</code> 只用于 <code>v-show</code> 中, 在 <code>v-if</code> 中使用时无效的, 永远不会被触发, 其触发时机是在离开动画(即 <code>xxx-leave-active</code> 动画)播放未完成的时候, 又执行了其他动画的时候触发.</p>\n<p>测试代码:</p>\n<pre><code class="hljs html">&lt;button <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"button"</span> <span class="hljs-meta">@click</span>=<span class="hljs-string">"show=!show"</span>&gt;点击我切换状态&lt;/button&gt;\n&lt;transition name=<span class="hljs-string">"go"</span>\n  <span class="hljs-meta">@before</span>-enter=<span class="hljs-string">"beforeEnter"</span>\n  <span class="hljs-meta">@enter</span>=<span class="hljs-string">"enter"</span>\n  <span class="hljs-meta">@after</span>-enter=<span class="hljs-string">"afterEnter"</span>\n  <span class="hljs-meta">@enter</span>-cancelled=<span class="hljs-string">"enterCancelled"</span>\n  <span class="hljs-meta">@before</span>-leave=<span class="hljs-string">"beforeLeave"</span>\n  <span class="hljs-meta">@leave</span>=<span class="hljs-string">"leave"</span>\n  <span class="hljs-meta">@after</span>-leave=<span class="hljs-string">"afterLeave"</span>\n  <span class="hljs-meta">@leave</span>-cancelled=<span class="hljs-string">"leaveCancelled"</span>\n&gt;\n此处使用 v-show, 修改成 v-<span class="hljs-keyword">if</span> 的时候发现, leave-cancelled 不会触发.\n&lt;p v-show=<span class="hljs-string">"show"</span>&gt;\n  点击展示我, 再点击一下隐藏我.\n&lt;/p&gt;\n&lt;/transition&gt;\n</code></pre>\n<p>逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-selector-tag">data</span>(){\n  <span class="hljs-selector-tag">return</span>{\n    <span class="hljs-attribute">show</span>: true\n  }\n},\n<span class="hljs-attribute">methods</span>: {\n  beforeEnter(){alert(<span class="hljs-number">1</span>);},\n  <span class="hljs-selector-tag">enter</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">2</span>);},\n  <span class="hljs-selector-tag">afterEnter</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">3</span>);},\n  <span class="hljs-selector-tag">enterCancelled</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">4</span>);},\n  <span class="hljs-selector-tag">beforeLeave</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">5</span>);},\n  <span class="hljs-selector-tag">leave</span>(){<span class="hljs-selector-tag">alert</span>(<span class="hljs-number">6</span>);},\n  <span class="hljs-selector-tag">afterLeave</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">7</span>);},\n  <span class="hljs-selector-tag">leaveCancelled</span>(){ <span class="hljs-selector-tag">alert</span>(<span class="hljs-number">8</span>);}\n},\n</code></pre>\n<p>样式:</p>\n<pre><code class="hljs css"><span class="hljs-selector-class">.button-animate</span> <span class="hljs-selector-tag">button</span>{\n  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40px</span>;\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;\n  <span class="hljs-attribute">position</span>: absolute;\n}\n<span class="hljs-selector-class">.go-enter-active</span> {\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">5s</span> ease;\n}\n<span class="hljs-selector-class">.go-leave-active</span> {\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(1.0, 0.5, 0.8, 1.0);\n}\n<span class="hljs-selector-class">.go-enter</span>, <span class="hljs-selector-class">.go-leave-active</span> {\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(10px);\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n}\n</code></pre>\n<p>钩子们的参数除了 <code>enter</code> 和 <code>leave</code> 是 <code>el</code> 元素本身(原生的 <code>Element</code> 类型元素), 和 <code>done</code> 回调函数外, 其他钩子的参数均为 <code>el</code> 元素本身.</p>\n<p>元素的过渡, 最好给每个元素加个 <code>key</code>, 因为之前提到的就地复用策略, 可能在切换的时候直接替换数据, 没有动画效果.</p>\n<p>在官方文档中完全没有说明的一点是, <code>Vue transition</code> 的动画类名 <code>css</code> 的写法是有顺序限制的, <code>v-enter</code> 和 <code>v-leave</code> 必须写在 <code>v-enter-active</code> 和 <code>v-leave-active</code> 的后面, 否则无效, 比如我想写一个点击按钮的淡入淡出效果, 点击按钮之后会有一个按钮从左向右淡入, 同时当前点击的按钮任从左往右淡出:\n逻辑:</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">data</span>:{\n  isShow: <span class="hljs-literal">true</span>\n},\nmethods:{\n  animakkey(){\n    <span class="hljs-keyword">this</span>.isShow = !<span class="hljs-keyword">this</span>.isShow;\n  } \n}\n</code></pre>\n<p>结构:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">"button-animate"</span>&gt;\n  &lt;<span class="hljs-attribute">transition</span> name=<span class="hljs-string">"go"</span>&gt;\n    &lt;<span class="hljs-selector-tag">button</span> key=<span class="hljs-string">"a"</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"isShow"</span> @click=<span class="hljs-string">"animakkey"</span>&gt;on&lt;/button&gt;\n    &lt;<span class="hljs-selector-tag">button</span> key=<span class="hljs-string">"b"</span> v-<span class="hljs-keyword">else</span> @click=<span class="hljs-string">"animakkey"</span>&gt;off&lt;/button&gt;\n  &lt;/<span class="hljs-attribute">transition</span>&gt;\n&lt;/div&gt;\n</code></pre>\n<p>如果你的样式是这样的:</p>\n<pre><code class="hljs css"><span class="hljs-selector-class">.button-animate</span> <span class="hljs-selector-tag">button</span>{\n  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40px</span>;\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;\n  <span class="hljs-attribute">position</span>: absolute;\n}\n<span class="hljs-selector-class">.go-enter</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-25px);\n}\n<span class="hljs-selector-class">.go-leave</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(25px);\n}\n<span class="hljs-selector-class">.go-enter-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(0px);\n}\n\n<span class="hljs-selector-class">.go-leave-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(50px);\n}\n</code></pre>\n<p>会发现动画效果并不如意:</p>\n<p><img src="http://img.xheldon.com/img/animateBad.gif" alt="animate" title="animate"></p>\n<p>而如果把 <code>enter</code> 放到 <code>enter-active</code> 的后面:</p>\n<pre><code class="hljs css"><span class="hljs-selector-class">.button-animate</span> <span class="hljs-selector-tag">button</span>{\n  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40px</span>;\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;\n  <span class="hljs-attribute">position</span>: absolute;\n}\n<span class="hljs-selector-class">.go-enter-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(0px);\n}\n<span class="hljs-selector-class">.go-enter</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-25px);\n}\n<span class="hljs-selector-class">.go-leave-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(50px);\n}\n<span class="hljs-selector-class">.go-leave</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(25px);\n}\n</code></pre>\n<p>就完美了:</p>\n<p><img src="http://img.xheldon.com/img/animateGood.gif" alt="animate" title="animate"></p>\n<p>在对比了这四个 <code>css</code> 类名的可能顺序之后, 发现只要 <code>v-enter</code> 放到 <code>v-enter-active</code> 的后面就能实现效果, 其他类名随意.</p>\n<p><code>transition</code> 标签中不能放其他元素而只能是放需要动画的元素, 如果上述示例结构写成这个样子:</p>\n<pre><code class="hljs html">&lt;<span class="hljs-attribute">transition</span> name=<span class="hljs-string">"go"</span>&gt;\n&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">"button-animate"</span>&gt;\n  &lt;<span class="hljs-selector-tag">button</span> key=<span class="hljs-string">"a"</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"isShow"</span> @click=<span class="hljs-string">"animakkey"</span>&gt;on&lt;/button&gt;\n  &lt;<span class="hljs-selector-tag">button</span> key=<span class="hljs-string">"b"</span> v-<span class="hljs-keyword">else</span> @click=<span class="hljs-string">"animakkey"</span>&gt;off&lt;/button&gt;\n&lt;/div&gt;\n&lt;/<span class="hljs-attribute">transition</span>&gt;\n</code></pre>\n<p>则不会有任何动画效果, 而如果在正常 <code>css</code> 类名中使用一些 <code>css</code> 属性规定了元素的样式, 而在动画类名如 <code>v-enter</code> 中又使用了相同的属性, 则也不会生效, <a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名" target="_blank">文档</a>说&quot;他们的优先级高于普通的类名&quot;, 实则不然(也不知道是我理解错误?欢迎指正), 还是上例, 样式中, 设置 <code>button</code> 的正常 <code>css</code> 属性:</p>\n<pre><code class="hljs css"><span class="hljs-selector-class">.button-animate</span> <span class="hljs-selector-tag">button</span>{\n  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40px</span>;\n  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;\n  <span class="hljs-attribute">position</span>: absolute;\n  <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateX</span>(50px);\n}\n<span class="hljs-selector-class">.go-enter-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(0px);\n}\n<span class="hljs-selector-class">.go-enter</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-25px);\n}\n<span class="hljs-selector-class">.go-leave-active</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(50px);\n}\n<span class="hljs-selector-class">.go-leave</span>{\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(25px);\n}\n</code></pre>\n<p>结果:</p>\n<p><img src="http://img.xheldon.com/img/animateWithout.gif" alt="animate" title="animate"></p>\n<p>可以看到, 只有 <code>opacity</code> 产生了动画, <code>transform</code> 没有动画!(同学们可以测试下是用 <code>animate.css</code> 的时候, 使用 <code>Animate.css</code> 中相同的属性来提前设置元素, 是否还有动画效果, 欢迎提 <code>issue</code>.)</p>\n<p><code>transition-group</code> 和 <code>transition</code> 有点不太一样, 从外观上说, <code>transition</code> 本身只是个包裹容器, 不参与任何的页面构成, 但是 <code>transition-group</code> 却会被 <code>Vue</code> 替换为一个标签, 默认是 <code>span</code> 标签, 也可以定制被替换成的标签名.</p>\n<h2 id="-render-"><code>render</code> 函数</h2>\n<p>使用 <code>render</code> 函数可以代替写模板的作用, 其形参 <code>createElement</code> 一般被写成 <code>h</code>, 在组件或者标签内的各种绑定/属性等, 在 <code>createElement</code> 中都能找到对应的 <code>JavaScript</code> 写法, 如果找不到, 那就说明可以使用原生的写法, 比如 <code>.stop</code>, <code>.prevent</code> 等, 直接使用 <code>event.stopPropagation()</code> 和 <code>event.preventDefault()</code> 即可.</p>\n<h2 id="-">其他</h2>\n<p>混合(<code>mixin</code>), 就是指在写正常的组件过程中(也即在组件的生命周期中), 修改或者添加额外的功能.</p>\n<p>部分<code>插件</code>就是根据上面的 <code>mixin</code> 写的, 除此之外的插件还有往 <code>Vue.prototype</code> 添加方法, 或者通过 <code>config</code> 添加一些全局的方法或者属性.</p>\n<p><code>路由</code>, 可以通过 <code>component</code> 的 <code>is</code> 属性来简单实现, 也可以直接写 <code>render</code> 函数根据不同路径渲染不同模板, 当然更复杂的需要第三方库了.</p>\n<p><code>状态管理</code>, 看示例是要加个 <code>wrap</code> 来记录每个状态改变的过程, 然后官方建议的最佳实践是即使你能直接复制给示例属性, 但是也最好通过函数来修改状态, 因为这让状态变得可追踪.</p>\n<p><code>单元测试</code>, 就是正常的单元测试, 没什么好说的.</p>\n<h2 id="-server-side-render-">服务端渲染(<code>Server Side Render</code>)</h2>\n<p>看了下思路, 基本上很简单, 就是首先在 <code>app.js</code> 中 <code>exports</code> 一个 <code>Vue</code> 实例, 然后新建一个页面模板文件 <code>index.html</code>(引入 <code>Vue.js</code> 和挂载 <code>Vue</code> 实例的方法 <code>$mount</code>, 官网同样也引入了 <code>app.js</code>, 是否需要待我验证下再说), 含有实例的挂载点(一个带有 <code>id</code> 属性的非空元素), 然后在服务端 <code>server.js</code> 都 <code>require</code> 过来, 用 <code>vue-server-renderer</code> 这个东西, 把 <code>app.js</code> 中 <code>exports</code> 出去的 <code>Vue</code> 实例渲染下, 再在返回给客户端的时候替换掉挂载点(一个带有 <code>id</code> 属性的非空元素, 因为 <code>app.js</code> 中的模板已经存在了)即可.</p>\n<p>服务端渲染的结果就是, 会在上述的挂载点(一个带有 <code>id</code> 属性的非空元素)加一个 <code>server-rendered=&quot;true&quot;</code> 的属性(通过右键查看页面源代码查看存在, 说明不是 <code>js</code> 动态添加的).</p>\n<p>服务端也支持流式渲染, 首先需要把 <code>html</code> 以挂载点(一个带有 <code>id</code> 属性的非空元素,如 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>)为分割点, <code>split</code> 一下, 分为 <code>ab</code> 两个部分, 而刚刚使用的 <code>vue-server-renderer</code> 的是把 <code>app.js</code> <code>renderToString</code> 了, 而为了支持流式渲染, 需要换个方法叫 <code>renderToStream</code>, 然后监听 <code>data</code> 事件, 附加到, <code>html</code> 的 <code>a</code> 部分的后面, <code>end</code> 事件之后, 再拼接上 <code>html</code> 的 <code>b</code> 部分, 最后再一并 <code>res.send</code> 出去.</p>\n<h2 id="-">后记</h2>\n<p>坐标帝都, <code>ping</code> <code>cn.vuejs.org</code>:</p>\n<p><img src="http://img.xheldon.com/img/ping1.png" alt="ping" title="ping"></p>\n<p><code>ping</code> 我司<code>FQ</code> <code>VPS</code>:</p>\n<p><img src="http://img.xheldon.com/img/ping2.png" alt="ping" title="ping"></p>\n<p><code>dig</code> 一下:</p>\n<p><img src="http://img.xheldon.com/img/dig1.png" alt="dig" title="dig"></p>\n<p>可以看到使用的是 <code>cloudflare</code> 的服务, 国际网站不好做呀, 呵呵.</p>\n'}});